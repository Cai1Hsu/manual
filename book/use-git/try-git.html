<!DOCTYPE HTML>
<html lang="zh-cn" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Git 入门 - 東秦計科人生存手冊</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> 說明</a></li><li class="chapter-item expanded affix "><li class="part-title">通用篇</li><li class="chapter-item expanded "><a href="../get-started/markdown_syntax.html"><strong aria-hidden="true">2.</strong> Markdown 语法</a></li><li class="chapter-item expanded "><a href="../get-started/vscode.html"><strong aria-hidden="true">3.</strong> 使用 Visual studio code</a></li><li class="chapter-item expanded "><a href="../get-started/about-cs.html"><strong aria-hidden="true">4.</strong> 计算机类</a></li><li class="chapter-item expanded "><a href="../get-started/about-ei.html"><strong aria-hidden="true">5.</strong> 电子信息类篇</a></li><li class="chapter-item expanded affix "><li class="part-title">Git 的使用</li><li class="chapter-item expanded "><a href="../use-git/whatis.html"><strong aria-hidden="true">6.</strong> 什么是Git</a></li><li class="chapter-item expanded "><a href="../use-git/installation.html"><strong aria-hidden="true">7.</strong> 安装 Git</a></li><li class="chapter-item expanded "><a href="../use-git/configure.html"><strong aria-hidden="true">8.</strong> 配置 Git及简要的命令行教程</a></li><li class="chapter-item expanded "><a href="../use-git/hug-cli.html"><strong aria-hidden="true">9.</strong> 认识命令行</a></li><li class="chapter-item expanded "><a href="../use-git/try-git.html" class="active"><strong aria-hidden="true">10.</strong> Git 入门</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">東秦計科人生存手冊</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="git-入门"><a class="header" href="#git-入门">Git 入门</a></h1>
<p>在了解了命令行的基本操作后，我们来尝试使用 Git。这部分的内容是命令和原理结合的，你可以在这里学到 Git 的基本操作和 Git 的工作原理。</p>
<p>获得一个 Git 仓库的方法有两种，一种是“将一个文件夹变成 Git 仓库”，一种是从远程<strong>克隆</strong>一个 Git 仓库。</p>
<h2 id="将一个文件夹变成一个-git-仓库"><a class="header" href="#将一个文件夹变成一个-git-仓库">将一个文件夹变成一个 Git 仓库</a></h2>
<p>Git 仓库的本质是一个文件夹。所以，我们可以将一个文件夹变成一个 Git 仓库。</p>
<p>你可以输入以下命令，把当前文件夹变成一个 Git 仓库：</p>
<pre><code class="language-bash">git init
</code></pre>
<p>或者，你可以输入以下命令，把指定文件夹变成一个 Git 仓库：</p>
<pre><code class="language-bash">git init path/to/folder
</code></pre>
<p>Git 仓库和普通文件夹的区别在于，Git 仓库中有一个隐藏的<code>.git</code>文件夹，这个文件夹中存储了 Git 的所有信息，包括所有的git object，ref等。在任何情况下，你都不要应该修改<code>.git</code>文件夹中任何的内容。唯一的例外是<code>.git/config</code>文件，这个文件存储了当前仓库的配置信息，例如远程仓库的地址等。但是你也应该谨慎修改这个文件或者使用<code>git config</code>命令修改配置。</p>
<p>如果你不小心把一个文件夹变成了 Git 仓库<sup class="footnote-reference"><a href="#1">1</a></sup>，直接删除<code>.git</code>文件夹就可以了。使用以下命令即可：</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>去年有人才把整个C盘或者桌面都变成了Git仓库。</p>
</div>
<pre><code class="language-bash">rm -rf .git
</code></pre>
<p>Git 在操作 Git 仓库时，会递归的从当前文件夹向上查找<code>.git</code>文件夹，直到找到<strong>第一个</strong><code>.git</code>文件夹或者到达文件系统的根目录。所以，你可以在任何一个 Git 仓库的子文件夹中使用 Git 命令。当 Git 仓库嵌套时，Git 会使用离当前文件夹最近的<code>.git</code>文件夹。</p>
<h2 id="克隆远程仓库"><a class="header" href="#克隆远程仓库">克隆远程仓库</a></h2>
<p>要从远程克隆仓库首先要确保你具有权限，对于 GitHub，GitLab, Bitbucket等代码托管平台的公开仓库，任何人都具有权限，因此可以直接克隆。对于私有仓库，你需要一个具有读取权限的平台账号，然后将平台账户和你的 SSH 密钥绑定。</p>
<p>具有权限后，就能够克隆仓库了，使用以下命令即可：</p>
<pre><code class="language-bash">git clone https://github.dev/NEUQ-CS/manual.git
</code></pre>
<p>记得将仓库地址更换成你想克隆的仓库的地址。克隆结束后，在<strong>当前目录</strong>下会产生一个与仓库名一致的文件夹，在本例中，是<code>manual</code>。
这个仓库就是你克隆的 Git 仓库。</p>
<p><code>clone</code>命令还有一些其他参数可以使用</p>
<h4 id="克隆到指定文件夹"><a class="header" href="#克隆到指定文件夹">克隆到指定文件夹</a></h4>
<p>在地址后面加上指定路径即可：</p>
<pre><code class="language-bash">git clone https://github.dev/NEUQ-CS/manual.git path/to/repo
</code></pre>
<p>注意，仓库里的文件会直接存在你指定的文件夹里面，而不是在你指定的目录里放仓库文件夹。</p>
<h4 id="克隆指定分支"><a class="header" href="#克隆指定分支">克隆指定分支</a></h4>
<p>加上参数<code>-b &lt;分支名&gt;</code>即可，例如:</p>
<pre><code class="language-bash">git clone https://github.dev/NEUQ-CS/manual.git -b master
</code></pre>
<p>这将指定需要克隆master分支.</p>
<p>需要说明的是，即使你选择了一个分支，整个仓库的所有分支都实质上会被克隆下来，只是克隆完成后位于指定分支。</p>
<h4 id="指定克隆深度"><a class="header" href="#指定克隆深度">指定克隆深度</a></h4>
<p>使用<code>--depth &lt;深度&gt;</code>来指定克隆深度：</p>
<pre><code class="language-bash">git clone https://github.dev/NEUQ-CS/manual.git --depth=1
</code></pre>
<p>仅克隆主分支上包含最新一个提交的完整仓库，克隆的仓库<strong>不含有</strong>任何历史记录。不推荐使用，除非你只是为了临时下载代码并且不需要历史记录和其他分支。</p>
<h2 id="查看-git-仓库的状态"><a class="header" href="#查看-git-仓库的状态">查看 Git 仓库的状态</a></h2>
<p>在一个 Git 仓库中，你可以使用以下命令查看当前仓库的状态：</p>
<pre><code class="language-bash">git status
</code></pre>
<p>你会看到以下输出：</p>
<pre><code>On branch master
Your branch is up to date with 'origin/use-git'.

Changes to be committed:
  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
        modified:   src/use-git/configure.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        src/use-git/try-git.md

</code></pre>
<p>当前在分支<code>master</code>上，你的分支是最新的。<code>Changes to be committed</code>中列出了你修改的文件，<code>Untracked files</code>中列出了你新建的文件。</p>
<h3 id="git-工作原理"><a class="header" href="#git-工作原理">Git 工作原理</a></h3>
<p>在继续尝试前，我们先来了解一下 Git 的工作原理，你可能已经对上面的输出感到迷惑了。</p>
<p>在一个 Git 仓库的文件夹中，一个文件可能存在以下三种状态的其中一种：</p>
<ul>
<li>未跟踪　Untracked</li>
<li>已跟踪  Tracked</li>
<li>暂存中  Staged</li>
</ul>
<h4 id="未跟踪"><a class="header" href="#未跟踪">未跟踪</a></h4>
<p>当你使用 <code>git init</code>初始化一个仓库时，原有的所有文件都是<strong>未跟踪</strong>。Git <strong>不会</strong>管理任何未跟踪的文件，但是这个文件仍然存在于这个文件夹中。<em>不会管理</em>的意思在于，当你通过 git 操作仓库的状态时，未跟踪的文件不会被修改或删除。如果一定会造成修改<sup class="footnote-reference"><a href="#2">2</a></sup>，git 会阻止这次操作，直到你解决完冲突。</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>比如你有一个未跟踪的a.txt，然后你通过切换到另一个分支，合并另一个分支，拉取远程尝试覆盖（其他分支上存在已跟踪的a.txt）这个文件时，Git 会阻止这次操作。</p>
</div>
<h4 id="已跟踪"><a class="header" href="#已跟踪">已跟踪</a></h4>
<p>这应该是仓库中大部分文件存在的状态。当你刚远程克隆完一个仓库时，所有文件都处于已跟踪状态。这是显然的，因为只有被跟踪的文件才会被提交到远程服务器。</p>
<h5 id="跟踪未跟踪的文件"><a class="header" href="#跟踪未跟踪的文件">跟踪未跟踪的文件</a></h5>
<p>要把一个未跟踪的文件变为已跟踪状态的方法是，先添加到<strong>暂存区</strong>，然后再commit。以下是命令行教程</p>
<pre><code class="language-bash"># 添加a_new_file到暂存区
git add a_new_file
# commit在暂存区的所有文件
git commit -m &quot;add `a_new_file` to this repo&quot;
</code></pre>
<h5 id="将已跟踪的文件删除"><a class="header" href="#将已跟踪的文件删除">将已跟踪的文件删除</a></h5>
<p>你可以使用<code>git rm &lt;文件&gt;</code>来删除，这会直接把删除操作直接添加到暂存区，文件系统上的文件也会被删除。它等价于以下操作：</p>
<pre><code class="language-bash">rm an_old_file
git add an_old_file
</code></pre>
<p>要取消跟踪一个文件，但希望在文件系统上保留这个文件，使用<code>git rm --cached file</code></p>
<h4 id="暂存中"><a class="header" href="#暂存中">暂存中</a></h4>
<p>准确地说，暂存的不是文件，是操作。通常来说，可以暂存</p>
<ul>
<li>修改 Modify/Update</li>
<li>添加 Add</li>
<li>删除 delete</li>
<li>移动 Move</li>
</ul>
<p>这几种操作。</p>
<p>当你在文件系统上修改一个文件，然后用<code>git add</code>的时候会暂存一个<code>修改</code>操作到暂存区。
当你在文件系统上添加一个文件，然后用<code>git add</code>的时候会暂存一个<code>添加</code>操作到暂存区。
当你在文件系统上删除一个文件，然后用<code>git add</code>的时候会暂存一个<code>删除</code>操作到暂存区。
当你在文件系统上移动或重命名一个文件，然后用<code>git add</code>的时候会暂存一个<code>移动</code>操作到暂存区。</p>
<p>将操作从暂存区撤出，使用以下命令：</p>
<pre><code class="language-bash">git restore --staged file
</code></pre>
<p>对于这些状态的理解，我推荐使用Visual studio code的内置Git功能进行观察，他是Git的一个前端。可以代替手动的命令行，但是，就我个人而言，更会倾向使用命令行，因为这些前端<strong>不支持</strong>较为复杂的操作。</p>
<p>现在我们再来看这段输出：</p>
<pre><code class="language-ascii">On branch master
Your branch is up to date with 'origin/use-git'.

Changes to be committed:
  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
        modified:   src/use-git/configure.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        src/use-git/try-git.md

</code></pre>
<p>Changes to be committed部分就是存在于暂存区的文件，当我们使用<code>git commit</code>的时候，就会跟踪并把这些文件添加到git仓库。</p>
<p>Untracked files是前文说过的未跟踪文件，这是因为这个文件才创建，当使用<code>git add</code>来添加时，会在暂存区添加一个<code>添加</code>操作。</p>
<h4 id="代码提交"><a class="header" href="#代码提交">代码提交</a></h4>
<p>代码提交使用<code>git commit</code>命令，提交的时候需要一段简短的话描述你的这次修改。同时，你的姓名，邮箱也会被记录在这条commit记录中。</p>
<p>关于如何编写commit信息，我会在后面讲解良好的git使用习惯时讲到。</p>
<p><code>git commit</code>命令常用的形式有以下两种：</p>
<ol>
<li>将信息作为参数直接提交</li>
</ol>
<pre><code class="language-bash">git commit -m &quot;&lt;提交信息&gt;&quot;
</code></pre>
<ol start="2">
<li>使用代码编辑器编写提交信息</li>
</ol>
<pre><code class="language-bash">git commit -a
</code></pre>
<p>这会打开你在安装时选择的代码编辑器，信息编写完成后，保存关闭即可。</p>
<p>有时候，你觉得提交信息写的不好，打算重写编写提交信息时，可以采用以下命令：</p>
<pre><code class="language-bash">git commit --amend -m &quot;&lt;提交信息&gt;&quot;
</code></pre>
<p>或者使用编辑器</p>
<pre><code class="language-bash">git commit --amend -a
</code></pre>
<p>这会完全重新提交一次commit并获得不同的commit哈希<sup class="footnote-reference"><a href="#3">3</a></sup>，以及时间戳。</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>还记得 Git 是去中心化这句话吗？使用哈希来描述对象是去中心化的典型特征。哈希是指向去中心化网络中对象的一个指针，具有这个指针就能够访问到这个对象，当没有人持有哈希时，这个对象就<em>视为</em>被删除，但是这个对象本身实际上不能被删除，它仍存在于去中心化网络中。Git 的commit也是，这也就意味着，当你在GitHub上删除一个仓库，分支时，它实际上从未被删除，也不能够被删除。</p>
</div>
<p>使用<code>git commit --amend</code>的操作等价于以下操作：</p>
<pre><code class="language-bash"># 保留修改回到上一次提交
git reset --soft &quot;HEAD^&quot;
# 重新提交
git commit -m &quot;&lt;提交信息&gt;&quot;
</code></pre>
<p>我个人更喜欢这种方法，因为更为灵活，你可以在重新提交过程中做一些修改。</p>
<h4 id="查看提交历史"><a class="header" href="#查看提交历史">查看提交历史</a></h4>
<p>使用<code>git log</code>命令可以查看提交历史，这会列出所有的提交记录，包括提交哈希，提交信息，提交时间，提交者等信息。</p>
<h4 id="推送到远程仓库"><a class="header" href="#推送到远程仓库">推送到远程仓库</a></h4>
<p>尽管我还没有教你配置远程仓库，但是我还是会告诉你如何推送到远程仓库。</p>
<p>使用<code>git push</code>命令可以将本地仓库的修改推送到远程仓库。这个命令的形式是：</p>
<pre><code class="language-bash">git push &lt;远程仓库名&gt; &lt;本地分支&gt;:&lt;远程分支&gt;
</code></pre>
<p>通常来说，远程仓库名是<code>origin</code>。并且，大多数时候，本地分支和远程分支是一样的，所以可以省略远程分支：</p>
<pre><code class="language-bash">git push origin &lt;分支&gt;
</code></pre>
<p>这会将本地分支推送到远程分支，如果远程分支不存在，会自动创建。</p>
<p>有时候，远程分支上包含了你不希望存在的修改，这时候你想用本地分支覆盖远程分支，可以使用<code>-f</code>参数：</p>
<pre><code class="language-bash">git push -f origin &lt;分支&gt;
</code></pre>
<p><code>-f</code>选项会强制推送，这会覆盖远程分支上的所有修改，所以请谨慎使用。如果你把别人的代码或者作业给覆盖了，小心被打。</p>
<p>在推送之前，你需要先确保你具有远程仓库的所有历史记录，如果本地仓库不包含远程仓库存在的一些更改，你就需要先拉取远程仓库的更改。</p>
<h4 id="拉取远程仓库的修改"><a class="header" href="#拉取远程仓库的修改">拉取远程仓库的修改</a></h4>
<p>拉取远程仓库的修改使用<code>git pull</code>命令，这会将远程仓库的修改拉取到本地仓库。这个命令的形式是：</p>
<pre><code class="language-bash">git pull &lt;远程仓库名&gt; &lt;远程分支&gt;:&lt;本地分支&gt;
</code></pre>
<p>同样，大多数时候，远程仓库名是<code>origin</code>，远程分支和本地分支是一样的，所以可以省略远程分支：</p>
<pre><code class="language-bash">git pull origin &lt;分支&gt;
</code></pre>
<p>这会将远程分支拉取到本地分支，如果本地分支不存在，会自动创建。</p>
<p><code>git pull</code>命令实际上是<code>git fetch</code>和<code>git merge</code>的组合，<code>git fetch</code>会将远程仓库的修改拉取到本地仓库，但不会应用更改，而是会在一个<code>&lt;远程名&gt;/&lt;分支名&gt;</code>的分支上保存，<code>git merge</code>会将这个特殊分支合并到本地分支。</p>
<h3 id="分支"><a class="header" href="#分支">分支</a></h3>
<p>前面提到了那么多关于分支的内容，但是我还没有告诉你什么是分支。</p>
<p>分支是 Git 的一个重要概念，它是一个指向一个提交的指针。在一个 Git 仓库中，你可以有多个分支，每个分支指向一个提交。默认情况下，你会有一个<code>master</code><sup class="footnote-reference"><a href="#1">1</a></sup>分支。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>前几年由于一些政治正确的原因，在GitHub上，主分支被改成了<code>main</code></p>
</div>
<p>分支的意义在于它和其他分支可以并行开发，你可以在一个分支上开发一个新的功能，而不影响其他分支。当你开发完成后，你可以将这个分支<strong>合并</strong>到主分支上。合并会将当前分支上所有领先于基础分支的patch应用到基础分支上。这就是使用 Git 进行协作开发的原理。</p>
<p>了解了什么是分支，现在我来教你如何管理分支。</p>
<h4 id="查看分支"><a class="header" href="#查看分支">查看分支</a></h4>
<p>使用<code>git branch</code>命令可以查看当前<strong>本地仓库</strong>的所有分支。加上<code>-a</code>参数可以查看所有分支，包括远程分支。</p>
<p>样例输出：</p>
<pre><code class="language-bash">caiyi@archlinux ~/r/manual (use-git)&gt; git branch
  fix-ci
  fix-format
  main
  master
* use-git
caiyi@archlinux ~/r/manual (use-git)&gt; git branch -a
  fix-ci
  fix-format
  main
  master
* use-git
  remotes/origin/HEAD -&gt; origin/main
  remotes/origin/fix-ci
  remotes/origin/fix-format
  remotes/origin/main
  remotes/origin/master
  remotes/origin/use-git
</code></pre>
<p>上面的输出表明，我们当前在<code>use-git</code>分支上，本地仓库中有<code>fix-ci</code>, <code>fix-format</code>, <code>main</code>, <code>master</code>, <code>use-git</code>五个分支，远程仓库中有<code>fix-ci</code>, <code>fix-format</code>, <code>main</code>, <code>master</code>, <code>use-git</code>五个分支。</p>
<h4 id="创建分支"><a class="header" href="#创建分支">创建分支</a></h4>
<p>创建分支是<em>创建当前分支的拷贝</em>，因此要先切换到你想要拷贝的分支上，然后使用命令。</p>
<p>创建分支有两种命令：</p>
<ol>
<li></li>
</ol>
<pre><code class="language-bash">git checkout -b &lt;分支名&gt;
</code></pre>
<ol start="2">
<li></li>
</ol>
<pre><code class="language-bash">git branch -m &lt;分支名&gt;
</code></pre>
<p>这会创建一个新的分支，并切换到这个分支上。</p>
<p>要创建一个分支但不切换到这个分支上，可以使用以下命令：</p>
<pre><code class="language-bash">git branch &lt;分支名&gt;
</code></pre>
<h4 id="切换分支"><a class="header" href="#切换分支">切换分支</a></h4>
<p>当两个分支里的文件不一样时，切换分支会修改当前文件系统上的文件，因为切换分支意味着你要切换到另一个分支的文件系统状态。</p>
<p>切换分支使用<code>git checkout</code>命令，这会将当前分支切换到指定分支上：</p>
<pre><code class="language-bash">git checkout &lt;分支名&gt;
</code></pre>
<h4 id="删除分支"><a class="header" href="#删除分支">删除分支</a></h4>
<p>删除分支使用<code>git branch -d</code>命令，这会删除指定分支：</p>
<pre><code class="language-bash">git branch -d &lt;分支名&gt;
</code></pre>
<p>如果分支上有未合并的修改，Git 会拒绝删除这个分支。如果你确定要删除这个分支，可以使用<code>-D</code>参数：</p>
<pre><code class="language-bash">git branch -D &lt;分支名&gt;
</code></pre>
<h4 id="合并分支"><a class="header" href="#合并分支">合并分支</a></h4>
<p>合并分支有三种方法：</p>
<ul>
<li>合并 merge</li>
<li>变基 rebase</li>
<li>快进 fast-forward</li>
</ul>
<p>通常来说，使用<code>merge</code>即可，但是在一些特殊情况下，你可能需要使用<code>rebase</code>。快进是一种特殊的合并，当你的分支是基于基础分支的最新提交时，Git 会直接将基础分支指针指向当前分支指针，这就是快进。</p>
<p>合并分支使用<code>git merge</code>命令，这会将<strong>指定分支合并到当前分支上</strong>：</p>
<pre><code class="language-bash">git merge &lt;另一个分支&gt;
</code></pre>
<p>合并分支会产生一个新的提交commit，这个提交包含了两个分支的所有修改。</p>
<h4 id="变基"><a class="header" href="#变基">变基</a></h4>
<p>变基是一个相对复杂的概念，相对于<code>merge</code>来说，它能够让提交记录更加<em>线性</em>。这是因为，在合并后，分支继承了基础分支，也同时继承了合并分支，同时具有两个父节点。这会使得提交记录变得复杂，也就是更加<strong>不线性</strong>。</p>
<p>变基与合并不同的地方在于，它不会让分支同时继承两个父节点，而是将合并分支的提交记录放在基础分支的最新提交之后。提供更改的分支不会被继承，因而不会出现两个父节点。</p>
<p>变基使用<code>git rebase</code>命令，这会将<strong>指定分支变基到当前分支上</strong>：</p>
<pre><code class="language-bash">git rebase &lt;另一个分支&gt;
</code></pre>
<p>变基会产生一个新的提交commit，这个提交包含了两个分支的所有修改。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>本节课我们学习了 Git 的基本操作，包括将一个文件夹变成 Git 仓库，克隆远程仓库，查看 Git 仓库的状态，提交代码，查看提交历史，推送到远程仓库，拉取远程仓库的修改，分支的创建，切换，删除，合并，变基等操作。</p>
<p>这些操作需要你多加练习，只有多加练习，你才能熟练掌握这些操作。</p>
<p>要练习这些操作，我推荐使用这个网站：<a href="https://learngitbranching.js.org/">Learn Git Branching</a>。使用这个网站时，你只需要先掌握基本操作，以及操作远程仓库的操作，就可以了。对于更加复杂的操作，等你对 Git 有了更深的理解再去尝试。</p>
<p>但更重要的是，你应该多使用 Git 来管理你的代码，这样你才能更好地理解 Git 的工作原理。</p>
<p>下一节课开始，我们将学习如何使用代码托管平台，本教程以 GitHub 为例。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../use-git/hug-cli.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../use-git/hug-cli.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
