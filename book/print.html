<!DOCTYPE HTML>
<html lang="zh-cn" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>東秦計科人生存手冊</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 說明</a></li><li class="chapter-item expanded affix "><li class="part-title">通用篇</li><li class="chapter-item expanded "><a href="get-started/markdown_syntax.html"><strong aria-hidden="true">2.</strong> Markdown 语法</a></li><li class="chapter-item expanded "><a href="get-started/vscode.html"><strong aria-hidden="true">3.</strong> 使用 Visual studio code</a></li><li class="chapter-item expanded "><a href="get-started/about-cs.html"><strong aria-hidden="true">4.</strong> 计算机类</a></li><li class="chapter-item expanded "><a href="get-started/about-ei.html"><strong aria-hidden="true">5.</strong> 电子信息类篇</a></li><li class="chapter-item expanded affix "><li class="part-title">Git 的使用</li><li class="chapter-item expanded "><a href="use-git/whatis.html"><strong aria-hidden="true">6.</strong> 什么是Git</a></li><li class="chapter-item expanded "><a href="use-git/installation.html"><strong aria-hidden="true">7.</strong> 安装 Git</a></li><li class="chapter-item expanded "><a href="use-git/configure.html"><strong aria-hidden="true">8.</strong> 配置 Git及简要的命令行教程</a></li><li class="chapter-item expanded "><a href="use-git/hug-cli.html"><strong aria-hidden="true">9.</strong> 认识命令行</a></li><li class="chapter-item expanded "><a href="use-git/try-git.html"><strong aria-hidden="true">10.</strong> Git 入门</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">東秦計科人生存手冊</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="暑假不发霉手册"><a class="header" href="#暑假不发霉手册">暑假不发霉手册</a></h1>
<blockquote>
<h3 id="作者栏-排名不分先后"><a class="header" href="#作者栏-排名不分先后">作者栏 （<em>排名不分先后</em>）</a></h3>
<blockquote>
<p><strong>计算机与通信工程学院  王思博</strong></p>
<p><strong>计算机与通信工程学院  唐德斌</strong></p>
</blockquote>
</blockquote>
<hr />
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>​	本软件仅供学习交流如作他用，如做商用与科研，请请示团队，所承受的法律责任一概与作者无关。</p>
<p>​	学习路线是笔者本身经历，对于具体问题需要具体分析</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h3 id="markdown语法市面上有很多编辑器笔者这里使用的是typora"><a class="header" href="#markdown语法市面上有很多编辑器笔者这里使用的是typora">Markdown语法（市面上有很多编辑器，笔者这里使用的是Typora）</a></h3>
<p><a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法 | Markdown 官方教程</a>，这里非常详细的记录了markdown常用的各种语法，本文作为介绍目标，只指出作者认为使用得多的一部分。</p>
<ol>
<li><strong>创建不同级标题</strong></li>
</ol>
<p>​	markdown语法创建标题只需要输入<code>#</code>+<code>space(空格)</code>，一个<code>#</code>表示一级标题，两个<code>#</code>，即<code>##</code>，表示二级标题，以此类推，几个<code>#</code>就是几级标题。</p>
<p><strong>演示如下</strong></p>
<hr />
<p><strong>源代码</strong></p>
<pre><code class="language-markdown"># 一级标题
## 二级标题
## 三级标题
</code></pre>
<h1 id="一级标题"><a class="header" href="#一级标题">一级标题</a></h1>
<h2 id="二级标题"><a class="header" href="#二级标题">二级标题</a></h2>
<h3 id="三级标题"><a class="header" href="#三级标题">三级标题</a></h3>
<hr />
<p><strong>演示结束</strong></p>
<ol start="2">
<li>
<p><strong>强调语法</strong></p>
<ul>
<li>
<p><strong>粗体 (Blod)</strong></p>
<p>要加粗文本，请在单词或短语的前后各添加两个星号<code>**</code>，效果如标题。</p>
</li>
<li>
<p><em>斜体（Italic)</em></p>
<p>要用斜体显示文本，请在单词或短语前后添加一个星号<code>*</code>，效果如标题。</p>
</li>
</ul>
</li>
<li>
<p><strong>引用</strong></p>
<p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p>
<p><strong>演示如下</strong> </p>
<hr />
<p><strong>源代码</strong></p>
<pre><code class="language-Markdown">&gt; 东北大学计算机与通信工程学院
</code></pre>
<blockquote>
<p>东北大学计算机与通信工程学院</p>
</blockquote>
</li>
</ol>
<hr />
<p><strong>演示结束</strong></p>
<ol start="4">
<li>
<p><strong>创建列表</strong></p>
<p>由于篇幅限制，笔者这里只介绍了有序列表。同样，对于其他用法请参考文处给出的网页。</p>
<p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p>
<p><strong>演示如下</strong> </p>
<hr />
<p><strong>源代码</strong></p>
<pre><code class="language-Markdown">1. First item
2. Second item
3. Third item
4. Fourth item
</code></pre>
</li>
<li>
<p>First item</p>
</li>
<li>
<p>Second item</p>
</li>
<li>
<p>Third item</p>
</li>
<li>
<p>Fourth item</p>
</li>
</ol>
<hr />
<p><strong>演示结束</strong></p>
<ol start="5">
<li>
<p><strong>代码块的使用</strong></p>
<p>用三个 `，即 ```` `，输入车便可以创建代码块，这一点在大一上的代码学习中有很大作用，以下代码为笔者展示C++的第一段程序</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
int main(){
	std::cout&lt;&lt;&quot;Welcome to Northeast University at Qinhuangdao!&quot;;
    return 0;
}
</code></pre>
<p><strong>TIPS：</strong></p>
<p>markdown的分享就结束了，但是作为一款功能强大的编辑语言，更多的功能在开头的文档等你探索。</p>
<p>笔者推荐的软件有：</p>
</li>
</ol>
<p>地址：   <a href="https://typoraio.cn/">Typora</a> </p>
<hr />
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<h3 id="vscode"><a class="header" href="#vscode">Vscode</a></h3>
<p>-----以Vscode配置C++为例</p>
<hr />
<p><strong>Github链接与使用</strong></p>
<hr />
<p><strong>数学建模相关</strong></p>
<p><strong>b站：</strong><a href="https://space.bilibili.com/400575790?spm_id_from=333.337.0.0">数学建模老哥</a></p>
<p><strong>b站：</strong><a href="https://www.bilibili.com/video/BV1DW411s7wi/?spm_id_from=333.337.search-card.all.click">清风数学建模</a></p>
<p>以上两个是b站名气最高的数学建模讲解，如有需要软件，这些视频简介中都有获取方式</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="计算机类篇"><a class="header" href="#计算机类篇">计算机类篇</a></h2>
<blockquote>
<hr />
<blockquote>
<h2 id="入门"><a class="header" href="#入门">入门</a></h2>
</blockquote>
<h3 id="声明"><a class="header" href="#声明">声明</a></h3>
<p>笔者也是个蒟蒻，就个人的粗糙经历来给学弟学妹们浅谈一下。糕手很多，欢迎热爱算法的有志之士加入<strong>NEUQ-ACM俱乐部</strong>。</p>
<hr />
<blockquote>
<h3 id="语言"><a class="header" href="#语言">语言</a></h3>
</blockquote>
<p>语言的学习是基础的，也是最快的，初学<code>C++</code>可能有点门槛，但语言之间的共性会使得后续其他语言的学习更容易，所以请打开编辑器，从<code>Hello，world</code>开始吧！</p>
<pre><code class="language-C++">#incloud &lt;bits/stdc++.h&gt;
using namespace std;
int main(){
 cout&lt;&lt;&quot;Hello,World!&quot;;
 return 0;
}
</code></pre>
<hr />
<h3 id="怎么学"><a class="header" href="#怎么学">怎么学</a></h3>
<p>一切以实操为基础，你可以通过啃书，书上有很多细节和样例，但一定要理解之后自己手打一遍。</p>
<p>关于入门看什么书，但从语言来说，你们的教材是谭浩强，但个人不推荐，可以试试<strong>C++ Primer</strong>和<strong>C++ Primer Plus</strong>（tb/pdd直接搜，出来的白皮封面大抵就是了，买来可别堆灰哦）</p>
<p>语言的学习很快，具体的语法也是错综复杂，但在算法领域大多都用不到，不必偏执.</p>
<hr />
<blockquote>
<h3 id="算法"><a class="header" href="#算法">算法</a></h3>
</blockquote>
<p>学算法前先学会打暴力，如果学会了打暴力，那么恭喜，你已经超过大部分人了，可以尝试在蓝桥杯中拿个省一</p>
<h3 id="怎么学-1"><a class="header" href="#怎么学-1">怎么学</a></h3>
<p>入门和学习在网上有很多资源，包括<code>b站</code>，<code>csdn</code>，<code>博客园</code>，<code>acwing</code>等等都有教学</p>
<p>也有专门的算法竞赛书籍，洛谷的**《深入浅出程序设计竞赛》<strong>和清华的</strong>《算法竞赛入门经典》**等等</p>
<p>基础的算法入门很快，而做题是需要人类智慧的。</p>
<p>网上有很多OJ，新手建议<code>洛谷</code>和<code>acwing</code>，他们也有入门题单等等。</p>
<p>刷题量差不多了，洛谷能看懂绿题和蓝题的题解，掌握了基础的算法（二分，DFS，BFS，动态规划，树状数组，线段树，并查集，二分图......）之后，就可以开始打一些网上的比赛了，牛客，洛谷，leetcode，codeforces，atcoder等平台都可以去打，在打比赛中更能锻炼自己的算法思维和码力。</p>
<p>至于进阶阶段的算法学习，acwing有提高和进阶的课程，也有一个网站可以参考学习<a href="https://oi-wiki.org/">OI Wiki - OI Wiki (oi-wiki.org)</a></p>
<p>至于拿奖，大一上除了个别OI爷有实力能直接打XCPC，暂时没有学校认定能加分的算法竞赛，不过有ACM的招新赛，欢迎大家在暑假以及开学后这段时间迅速入门C++，学会基本的暴力和解决问题的能力就能成为我们ACM俱乐部预备队的一员了。</p>
<p>不过大一下有很多比赛，希望大家好好沉淀，打几个比赛把科创分加满。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="电子信息类篇"><a class="header" href="#电子信息类篇">电子信息类篇</a></h2>
<blockquote>
<p>软件学习声明见前言，如做商用与科研，请请示团队</p>
<hr />
<h3 id="编程软件keil"><a class="header" href="#编程软件keil">编程软件：Keil</a></h3>
<p><strong>b站</strong>：<a href="https://www.bilibili.com/video/BV1th411z7sn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=2def49ca565e72b2dda6cd4e13bc7801">STM32入门教程-2023版 细致讲解 中文字幕_哔哩哔哩_bilibili</a></p>
<p>在简介中，有详细的物料清单和Keil的下载与破解方式。keil对应的单片机有：51单片机</p>
<p>其中51单片机涉及对寄存器操作，stm32涉及较多微机原理与模电数电，编程知识，虽然是最重要的单片机，但并不是初学者最友好的。</p>
<p><strong>优点</strong>：价格极其低廉
<strong>缺点</strong>：学习成本高昂</p>
<hr />
<h3 id="编程软件arduino-ide"><a class="header" href="#编程软件arduino-ide">编程软件：Arduino IDE</a></h3>
<p>地址：<a href="https://www.arduino.cc/en/software/">Software | Arduino</a></p>
<p>推荐新手入门uno r3,这款单片机价格便宜，可玩性强，重点是不像stm32一样涉及底层硬件知识，可以在学习C++的同时使用C语言进行编写。</p>
<p><strong>优点</strong>：价格相对低廉，学习成本相对低廉，不需要软件破解
<strong>缺点</strong>：体积相对较大</p>
<hr />
<h3 id="单片机类型microbit"><a class="header" href="#单片机类型microbit">单片机类型：micro:bit</a></h3>
<p>地址：<a href="https://microbit.org/zh-cn/code/">让我们开始编程吧 | micro:bit (microbit.org)</a></p>
<p>micro：bit最为最简单的单片机，在英国作为青少年教学单片机，在浙江作为技术选考教学单片机，使用python编程，具有代码编写简单，但是与后续的C++学习有一定的编程语言冲突</p>
<p><strong>优点</strong>：学习成本极其低廉（python非常好学）
<strong>缺点</strong>：价格极其昂贵</p>
<hr />
<h3 id="电路仿真软件multisim"><a class="header" href="#电路仿真软件multisim">电路仿真软件：Multisim</a></h3>
<p>地址：<a href="https://blog.csdn.net/u011816009/article/details/129643555">Multisim--软件简介及安装教程（含Multisim14安装包资源）-CSDN博客</a></p>
<p>由于是美国的软件，需要破解操作，安装与破解方法在上述网页</p>
<hr />
<h3 id="电路仿真软件pcb绘制软件嘉立创pro"><a class="header" href="#电路仿真软件pcb绘制软件嘉立创pro">电路仿真软件&amp;PCB绘制软件：嘉立创pro</a></h3>
<p>地址：<a href="https://lceda.cn/page/download?src=index">嘉立创pro</a></p>
<p>唯一真神，免费又好用。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是-git"><a class="header" href="#什么是-git">什么是 Git</a></h1>
<p>你在任何地方都可以找到这样一句话</p>
<blockquote>
<p>Git 是一个分布式版本控制系统，由 Linus Torvalds 于 2005 年创建。Git 是一个免费开源的软件，可以在任何操作系统上运行。</p>
</blockquote>
<p>这是正确的，但是作为一个新手来说，这句话可能并不是很容易理解。你不知道什么叫“分布式”，“版本控制系统”又是什么意思。甚至，你连 Git 有什么作用都不知道。</p>
<p>所以，让我们从一个简单的例子开始，来看看 Git 是如何工作的。</p>
<h2 id="一个简单的例子"><a class="header" href="#一个简单的例子">一个简单的例子</a></h2>
<p>假设我们有一个项目，通常来说，一个项目就是一个文件夹，里面有很多文件。这些文件是项目所需的代码，构建脚本，文档等等一切相关的东西。</p>
<p>现在来看这个<a href="https://github.com/NEUQ-CS/manual/tree/master/src/use-git/MyProject1">项目</a>，这是一个 C# 项目，你不需要了解 C#，只需要知道这是一个项目就可以了。</p>
<p>现在打开 <a href="https://github.com/NEUQ-CS/manual/tree/master/src/use-git/MyProject1/Program.cs">Program.cs</a> ，这是一个 C# 项目的入口文件，里面有一个简单的代码：</p>
<pre><code class="language-csharp">Console.WriteLine($&quot;Sum from 1 to 100 is {SumFrom1ToN(100)}&quot;);

int SumFrom1ToN(int n)
{
    int sum = 0;

    for (int i = 1; i &lt;= n; i++)
    {
        sum += i;
    }

    return sum;
}
</code></pre>
<p>你一看就知道，这是一个计算从 1 加到 100 的和的程序。你很好奇你的前辈为什么跟个弱智一样要手动从 1 加到 100。因为学过小学的都知道使用高斯公式就可以算出来，于是你决定进行修改：</p>
<pre><code class="language-csharp">Console.WriteLine($&quot;Sum from 1 to 100 is {SumFrom1ToN(100)}&quot;);

int SumFrom1ToN(int n)
{
    return n * ((n + 1) / 2);
}
</code></pre>
<p>然后把代码提交到了项目中。</p>
<p>不久，测试气冲冲地跑过来给了你一巴掌，因为<code>(n + 1)</code>是奇数时，结果会出错。现在需要fallback到原来的代码，但是不巧的是，没人记得原来的代码是什么样的了。</p>
<p>这时候，Git 就派上用场了。</p>
<p>Git 的作用是记录项目的历史，你可以在任何时候回到过去，查看项目的历史状态。这就好比是一个时间机器，你可以随时回到过去，查看项目的状态。每个状态被称为一个<code>commit</code>。当所有状态都被记录下来，你就可以随时回到任何一个状态。就不会出现像上面的情况了。</p>
<p>有人说，那我直接复制一份项目不就行了吗？实在行我就手动一条一条地改回去。这样不就可以了吗？</p>
<p>先别急，版本控制只是 Git 最基础的一个功能，但是 Git 的功能远远比这强大。最重要的功能是<code>协同工作</code>。</p>
<p><code>commit</code>的实质是一个patch，它记录了你对项目的哪些文件删除了哪些行，增加了哪些行。</p>
<p>比如，上文中你提交的代码的commit是这样的：</p>
<pre><code class="language-patch">diff --git a/Program.cs b/Program.cs
index c677648..1d522bd 100644
--- a/Program.cs
+++ b/Program.cs
@@ -3,12 +3,5 @@ Console.WriteLine($&quot;Sum from 1 to 100 is {SumFrom1ToN(100)}&quot;);
 
 int SumFrom1ToN(int n)
 {
-    int sum = 0;
-
-    for (int i = 1; i &lt;= n; i++)
-    {
-        sum += i;
-    }
-
-    return sum;
+    return n * ((n + 1) / 2);
 }
</code></pre>
<p>在 markdown 渲染下，你应该能清楚的理解我们所做的一切，修改发生在Program.cs，我们删除了 <code>int sum = 0;</code> 到 <code>return sum;</code> 这段代码，增加了 <code>return n * ((n + 1) / 2);</code> 这段代码。虽然还有些东西你看不懂，但是不要紧，我们后面会讲到。</p>
<p>这段patch可以被应用到任何一个拥有相同文件的项目上，而不仅仅是你的项目。当应用patch时，Git 会自动匹配相应的文件和代码行，然后应用patch。</p>
<p>当你的同伴在修改了项目的其他代码，比如在一开始加了一条<code>Console.WriteLine(&quot;Hello, world!&quot;)</code>，但是只要被应用patch的代码没有<code>冲突</code>，你的修改就可以被应用到项目上。</p>
<p>这就是 Git 的强大之处，它可以让你和你的同伴协同工作，而不会出现代码丢失。</p>
<p>至于冲突发生的时间，冲突的解决，我们后面会讲到。</p>
<p>接下来应该让你亲手体验一下 Git 的强大之处了，让我们准备安装 Git 吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装-git"><a class="header" href="#安装-git">安装 Git</a></h1>
<p>前文提到，Git<code>可以在任何操作系统上运行</code>。那么，本文将讲解在 Windows, Linux，以及 macOS 上如何安装 Git。</p>
<p>安装的部分大家跳转到适合自己操作系统的部分即可。</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>Windows 下安装Git稍微麻烦一些，因为Git本身是一个<strong>命令行</strong>工具，而Windows下的用户对命令行的使用并不是很熟悉，同时Windows下的命令行工具也跟垃圾一样难用。不过如果你会一点点命令行，并且有使用包管理器，你可以跳转到使用包管理器安装的部分。其他人就别看了，直接去<strong>手动安装</strong>部分吧。</p>
<p>需要说明的是，使用包管理器和手动安装，都是使用相同的软件来源，只是安装方式不同。因此效果是一样的。</p>
<h3 id="使用包管理器"><a class="header" href="#使用包管理器">使用包管理器</a></h3>
<p>如果你有使用 winget 包管理器，那么安装 Git 就像和在 Linux 下安装软件一样简单。Windows下有很多种包管理器，下面介绍两种最常见的包管理器winget 和 scoop上安装Git。</p>
<h4 id="使用-winget"><a class="header" href="#使用-winget">使用 winget</a></h4>
<p>使用以下命令安装 Git：</p>
<pre><code class="language-bash">winget install --id Git.Git -e --source winget
</code></pre>
<h4 id="使用-scoop"><a class="header" href="#使用-scoop">使用 scoop</a></h4>
<p>使用以下命令安装 Git：</p>
<pre><code class="language-bash">scoop install git
</code></pre>
<h3 id="手动安装"><a class="header" href="#手动安装">手动安装</a></h3>
<p>前往<a href="https://git-scm.com/download/windows">Git for Windows官网</a>。你应该会看到和下图类似的页面：</p>
<p><img src="use-git/./assets/download-git.png" alt="Git for Windows" /></p>
<p>现在，你需要根据你的机器选择合适的架构<sup class="footnote-reference"><a href="#1">1</a></sup>。对于大多数电脑用户来说，尤其是对于 Windows 10及以上的用户，选择<code>64-bit</code>即可。这些操作系统都是64位的。只要你的电脑不是十几年前的，一般都是64位的。</p>
<p>不过，即使你不知道自己的电脑是什么架构，也不用担心。Git官网自动帮你检测了你的电脑架构，你只需要点击巨大的<code>Download for Windows</code>标题下的<strong>Click here to download</strong>超链接即可。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>不同的架构使用不同的CPU指令集，因此选择错误的架构会导致Git无法运行。</p>
</div>
<p>下载完成后，双击下载的安装包，打开安装文件，<strong>你需要在下面几个页面注意一下选项</strong>，其他地方一路<code>Next</code>即可。一定要先看完再安装，不然后悔莫及。</p>
<p>我的图片是在Linux下使用Wine打开的，所以某些字体可能会有点问题，但是不影响理解。</p>
<h5 id="添加-git-bash-到-windows-terminal"><a class="header" href="#添加-git-bash-到-windows-terminal">添加 Git Bash 到 Windows Terminal</a></h5>
<p><img src="use-git/./assets/install1.png" alt="Select components" /></p>
<p>勾选倒数第二个选项<code>(New) Add a Git Bash Profile to Windows Terminal</code>。前面说过，Git 是一个<strong>命令行</strong>工具，而 Git Bash 是一个包含了Git的shell。这个选项会把 Git Bash 添加到 Windows Terminal 中，这样你就可以直接在 Windows Terminal 中使用 Git Bash 了。</p>
<p>Shell<sup class="footnote-reference"><a href="#2">2</a></sup> 是一个命令行解释器，它是一个程序，用于解释用户输入的命令，并执行这些命令。Windows下的命令行解释器是cmd和Powershell，而Git Bash是一个基于bash的Shell。</p>
<p>我们使用 Windows Terminal 是因为它是一个终端模拟器，可以同时打开多个终端，而且可以在一个窗口中同时打开不同的Shell。这样，你就可以在一个窗口中同时使用cmd，Powershell，Git Bash等Shell了。同时，Windows Terminal也能更好地支持复制粘贴等操作。</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>更准确地说，Git Bash是一个阉割版的 msys2，msys2和cygwin都是在Windows上提供类Unix环境的软件。bash是Unix上最常用的Shell之一。所以，Git Bash就是一个阉割后，只安装了Git和bash的msys2。</p>
</div>
<h5 id="选择默认编辑器"><a class="header" href="#选择默认编辑器">选择默认编辑器</a></h5>
<p><img src="use-git/./assets/install2.png" alt="Select editor" /></p>
<p>这个选项是选择你的默认编辑器。Git 会在一些情况下打开一个编辑器。大多数 Unix 用户都使用Vim/Neovim作为编辑器。但是，如果你不会/根本不知道Vim，请<strong>千万不要</strong>使用Vim。根据我的经验来看，大多数用户进入Vim后都不知道怎么退出。所以，请选择你在外部使用的编辑器，比如VS Code。如果没有，建议安装一个。实在不写可以使用Nano，这也是一个命令行的编辑器，但是它的操作都傻瓜式地写在屏幕下面了。</p>
<h5 id="选择默认换行符"><a class="header" href="#选择默认换行符">选择默认换行符</a></h5>
<p><img src="use-git/./assets/install3.png" alt="Select line endings" /></p>
<p>你可能听说过 Unix 系统使用<code>\n</code>作为换行符，Windows 使用<code>\r\n</code>作为换行符。这个选项就是选择你的默认换行符。请<strong>一定</strong><code>Checkout as-is, commit Unix-style line endings</code>即可。这个选项会在你检出代码时，使用Unix风格的换行符，提交代码时，使用Unix风格的换行符。否则，你在提交代码的时候很可能产生一大堆更改，因为换行符不同。</p>
<h5 id="启用软链接"><a class="header" href="#启用软链接">启用软链接</a></h5>
<p><img src="use-git/./assets/install4.png" alt="Enable symbolic links" />
把第二个选项<code>Enable symbolic links</code>勾选上。</p>
<p>软链接是一种特殊的文件，它指向另一个文件。软链接在Windows下叫做快捷方式。软链接在Unix下有两种，一种是符号链接，另一种是硬链接。符号链接是一种特殊的文件，它指向另一个文件。硬链接是一个文件的另一个名字。软链接在Windows下叫做快捷方式。这个选项是启用符号链接，这样你就可以在Git中使用软链接了。后面我们会稍微提到软链接，现在你你不许要知道这是什么。</p>
<p>接下来你就可以一路<code>Next</code>了。</p>
<p>安装完成后，在任意文件夹中按住<code>shift</code>，右键点击鼠标，你会看到<code>在此处打开 Git Bash</code>或者<code>Open Git Bash here</code>。点击这个选项，你就可以<strong>在当前文件夹</strong>中打开 Git Bash 了。</p>
<p><img src="use-git/./assets/git-bash-here.png" alt="Git Bash here" /></p>
<p>你也可以使用Windows Terminal，请先按照以下视频添加Git Bash的配置。</p>
<p><video src="./assets/add-profile.mp4" controls="controls"></video></p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>跳转到你的发行版的部分，按照你的发行版安装即可。</p>
<h3 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h3>
<pre><code class="language-bash">sudo pacman -S git
</code></pre>
<h3 id="debianubuntu"><a class="header" href="#debianubuntu">Debian/Ubuntu</a></h3>
<pre><code class="language-bash">sudo apt install git
</code></pre>
<h3 id="fedora"><a class="header" href="#fedora">Fedora</a></h3>
<pre><code class="language-bash">sudo dnf install git
</code></pre>
<h3 id="opensuse"><a class="header" href="#opensuse">openSUSE</a></h3>
<pre><code class="language-bash">sudo zypper install git
</code></pre>
<h3 id="gentoo"><a class="header" href="#gentoo">Gentoo</a></h3>
<p>自己编译去吧。</p>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<p>macOS 是基于 Unix 的操作系统，因此安装 Git 就像在 Linux 下安装软件一样简单。不过macOS不自带有包管理器，因此你需要自己安装一个包管理器。这里推荐使用 Homebrew。</p>
<h3 id="使用-homebrew"><a class="header" href="#使用-homebrew">使用 Homebrew</a></h3>
<pre><code class="language-bash">brew install git
</code></pre>
<h1 id="结束"><a class="header" href="#结束">结束</a></h1>
<p>安装完成后，你可以打开终端，输入<code>git --version</code>，然后回车，看到类似以下输出，说明安装成功：</p>
<pre><code class="language-bash">caiyi@archlinux ~&gt; git --version
git version 2.45.2
</code></pre>
<p>下一讲，我们将讲解如何配置 Git，以及简要介绍命令行和shell的基本操作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置-git及简要的命令行教程"><a class="header" href="#配置-git及简要的命令行教程">配置 Git及简要的命令行教程</a></h1>
<h2 id="配置-git"><a class="header" href="#配置-git">配置 Git</a></h2>
<p>首先按照上节课教你的方法打开终端或者 Git Bash。确保你能够从终端访问到git后，把这个窗口放在一边。</p>
<p>我们需要配置一些基本信息，包括：</p>
<ul>
<li>你的名字，一般是真实姓名，使用英文</li>
<li>你的邮箱，如果要使用 GitHub，这个邮箱必须和你的 GitHub 账号绑定</li>
<li>SSH 密钥</li>
</ul>
<p>让我们先从简单的来，配置你的名字和邮箱。</p>
<h3 id="配置名字和邮箱"><a class="header" href="#配置名字和邮箱">配置名字和邮箱</a></h3>
<h4 id="配置名字"><a class="header" href="#配置名字">配置名字</a></h4>
<p>在命令行中输入以下命令：</p>
<pre><code class="language-bash">git config --global user.name &quot;&lt;你的名字&gt;&quot;
</code></pre>
<p>姓名一定要用双引号括起来，否则空格后的内容会被忽略。</p>
<p>例子：</p>
<pre><code class="language-bash">git config --global user.name &quot;Caiyi Shyu&quot;
</code></pre>
<h4 id="配置邮箱"><a class="header" href="#配置邮箱">配置邮箱</a></h4>
<p>在命令行中输入以下命令：</p>
<pre><code class="language-bash">git config --global user.email &quot;&lt;你的邮箱&gt;&quot;
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">git config --global user.email &quot;cai1hsu@outlook.com&quot;
</code></pre>
<p>如果不小心输错了，可以再次输入命令进行更改。配置完成后，可以通过以下命令查看配置是否成功：</p>
<pre><code class="language-bash">git config --global user.name
git config --global user.email
</code></pre>
<p>在我的机器上，输出如下：</p>
<pre><code class="language-bash">caiyi@archlinux ~&gt; git config --global user.name
Caiyi Shyu
caiyi@archlinux ~&gt; git config --global user.email
cai1hsu@outlook.com
</code></pre>
<p>你的输出应该和你输入的一样。</p>
<p>我们在配置的时候都添加了<code>--global</code>选项，这意味着你在这台电脑上的所有仓库都会使用这个名字和邮箱。</p>
<p>在提交记录中，这个名字和邮箱会被记录下来，所以请确保你的名字和邮箱是正确的。</p>
<p>例如，在一个git仓库中，使用<code>git log</code>可以查看提交记录，其中有一个字段是<code>Author</code>，这个字段就是你的名字和邮箱。</p>
<p>例子：</p>
<pre><code class="language-ascii">Author: Caiyi Shyu &lt;cai1hsu@outlook.com&gt;
Date:   Wed Jul 31 16:54:32 2024 +0800

    fix click to expand on touch devices

commit 77d64e0c3d593d4b912a6fc8d2f1e16a9e46e9b8
</code></pre>
<h3 id="配置-ssh-密钥"><a class="header" href="#配置-ssh-密钥">配置 SSH 密钥</a></h3>
<p>当你访问在远程的仓库时，你需要凭证来证明你具有访问权限。在以前，代码托管平台允许你使用用户名和密码来访问仓库。但是现在，这种方式已经被淘汰了，因为它不够安全。</p>
<p>SSH 使用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">非对称加密</a>来保护你的数据。在这种加密方式中，有两个密钥：公钥和私钥。公钥是公开的，任何人都可以看到。私钥是私有的，只有你自己知道。使用一种密钥加密，则必须使用相配对的另一种密钥解密。除此之外，密钥无法被暴力破解，因为它的长度太长了。</p>
<p>SSH 密钥有不同算法，常用的有 RSA 和 ED25519。任选一种即可。</p>
<p>生成 SSH 密钥需要邮箱，请<strong>务必</strong>使用和上面一样的邮箱。</p>
<p>回到终端，输入以下命令：</p>
<pre><code class="language-bash">ssh-keygen -t &lt;算法&gt; -C &quot;&lt;邮箱&gt;&quot;
</code></pre>
<p>例子:</p>
<ol>
<li>RAS 算法</li>
</ol>
<pre><code class="language-bash"> ssh-keygen -t rsa -b 4096 -C &quot;cai1hsu@outlook.com&quot;
</code></pre>
<ol start="2">
<li>ED25519 算法</li>
</ol>
<pre><code class="language-bash"> ssh-keygen -t ed25519 -C &quot;cai1hsu@outlook.com&quot;
</code></pre>
<p><strong>注意！请不要复制我的例子，把例子中的邮箱替换成你的邮箱。</strong> </p>
<p>输入命令后，直接一路回车，直到你看到和以下内容相似的<strong>完整</strong>的输出：</p>
<pre><code class="language-bash">Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/codespace/.ssh/id_ed25519): 
Created directory '/home/codespace/.ssh'.
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/codespace/.ssh/id_ed25519
Your public key has been saved in /home/codespace/.ssh/id_ed25519.pub
The key fingerprint is:
SHA256:5SUADhuC/DSS66Zrzyj1Jqn6FMiQPv3ZAJUAYgjK940 your_email@example.com
The key's randomart image is:
+--[ED25519 256]--+
|*++.+.o..        |
|B= +.*   .       |
|+.=oo .   o .    |
|+oo.o o  o o     |
|o+.. E .S .      |
| oo.. +          |
|o..o o .         |
|oo= o            |
|B=o=             |
+----[SHA256]-----+
</code></pre>
<p>看到这个输出，说明你的 SSH 密钥已经生成成功了。请<strong>务必注意</strong>这个页面的输出<strong>不能</strong>分享给任何人。</p>
<p>不过你目前仍然不能通过 SSH 访问远程仓库，因为你的公钥还没有添加到远程仓库。在后面讲解GitHub工作流的章节中，我们会讲解如何添加公钥到远程仓库。</p>
<p>接下来，我们来学习一下命令行的基本操作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认识命令行"><a class="header" href="#认识命令行">认识命令行</a></h1>
<p>本页内容对于新手来说可能有些难度，你不需要理解所有内容，只需要确保你能够看懂命令行，并使用命令行来完成常见工作即可。</p>
<p>请认真对比命令行的内容和我对内容含义的解释，确保你理解命令行界面的含义。
以下是三种常见的命令行界面，分别是：</p>
<ol>
<li>Git Bash on Windows</li>
</ol>
<pre><code class="language-bash">Caiyi Shyu@archlinux MINGW64 ~
$ git --version
</code></pre>
<ol start="2">
<li>Bash on Unix</li>
</ol>
<pre><code class="language-bash">[caiyi@archlinux ~]$ git --version
</code></pre>
<ol start="3">
<li>Fish on Unix</li>
</ol>
<pre><code class="language-bash">caiyi@archlinux ~&gt; git --version
</code></pre>
<p>它们都含有以下几个部分：</p>
<ol>
<li><code>Caiyi Shyu@archlinux</code> 或者 <code>caiyi@archlinux</code></li>
<li><code>~</code></li>
<li><code>$</code> 或者 Fish 中的 <code>&gt;</code></li>
<li><code>git --version</code></li>
</ol>
<p>第一个部分是用户名和主机名，格式为<code>&lt;用户名&gt;@&lt;主机名&gt;</code>。</p>
<h4 id="用户名和主机名"><a class="header" href="#用户名和主机名">用户名和主机名</a></h4>
<p>在上面的例子中，用户名是<code>Caiyi Shyu</code>或者<code>caiyi</code>，主机名是<code>archlinux</code>。主机名是你的电脑的名字，在你操作系统的设置中可以找到并进行更改。</p>
<h4 id="工作目录"><a class="header" href="#工作目录">工作目录</a></h4>
<p>第二个部分是工作目录，格式为<code>&lt;工作目录&gt;</code>。在上面的例子中，工作目录是<code>~</code>。<code>~</code>表示用户的home目录，也就是你的用户目录。在 Windows 中，用户的家目录一般是<code>C:\Users\&lt;用户名&gt;</code>。在 Unix 中，用户的家目录一般是<code>/home/&lt;用户名&gt;</code>。</p>
<p>你也可以在终端中输入<code>pwd</code>命令来查看当前工作目录。
以下是在 Windows 和 Unix 中的输出：</p>
<ol>
<li>Git Bash on Windows</li>
</ol>
<pre><code>/c/Users/Caiyi Shyu/
</code></pre>
<p>看起来和 Windows 下常见的路径有些不一样。这是因为 Git Bash 使用 Unix 风格的路径。上面的路径等价于<code>C:\Users\Caiyi Shyu\</code>。注意，在Git Bash中，只能使用Unix风格的路径，并且路径分隔符是<code>/</code>而不是<code>\</code>。</p>
<ol start="2">
<li>Bash or Fish on Unix</li>
</ol>
<pre><code>/home/caiyi
</code></pre>
<p>这是完整目录，当前用户的<code>home</code>就等价于<code>~</code></p>
<p>当我进入当前目录下的<code>Desktop</code>目录时，工作目录会变成<code>~/Desktop</code>。</p>
<p>就像下面一样：</p>
<ol>
<li>Git Bash on Windows</li>
</ol>
<pre><code class="language-bash">Caiyi Shyu@archlinux MINGW64 ~/Desktop
$ 
</code></pre>
<ol start="2">
<li>Bash on Unix</li>
</ol>
<pre><code class="language-bash">[caiyi@archlinux ~/Desktop]$ 
</code></pre>
<ol start="3">
<li>Fish on Unix</li>
</ol>
<pre><code class="language-bash">caiyi@archlinux ~/Desktop&gt; 
</code></pre>
<p>现在输入<code>pwd</code>命令，你会看到输出是<code>/home/caiyi/Desktop</code>(Linux和macOS)或者<code>/c/Users/Caiyi Shyu/Desktop</code>(Windows)。</p>
<p><strong>需要说明的是，shell中的工作目录通常为了显示简洁，可能会省略一部分内容。如果你不清楚当前的工作目录，请随时<code>pwd</code>命令来查看。</strong></p>
<h4 id="提示符"><a class="header" href="#提示符">提示符</a></h4>
<p>第三个部分是提示符，格式为<code>&lt;提示符&gt;</code>。在上面的例子中，提示符是<code>$</code>或者<code>&gt;</code>。提示符告诉你终端已经准备好接受你的输入了。</p>
<h4 id="命令"><a class="header" href="#命令">命令</a></h4>
<p>第四个部分是命令，格式为<code>&lt;命令&gt;</code>。在上面的例子中，命令是<code>git --version</code>。这个命令告诉终端你想要执行<code>git</code>这个程序，并且传递了一个参数<code>--version</code>给这个程序。</p>
<p>命令是你和shell交互的方式。当你输入完命令后，按下回车键，shell会<strong>解释</strong><sup class="footnote-reference"><a href="#1">1</a></sup>并执行这个命令。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>解释是指shell会根据你输入的命令，找到对应的程序，并且传递参数给这个程序。程序会根据参数执行相应的操作。</p>
</div>
<p>命令分为两种：内建命令和外部命令。内建命令是shell自带的命令，比如<code>cd</code>，<code>pwd</code>，<code>exit</code>等。外部命令是你安装的程序，比如<code>git</code>，<code>ls</code>，<code>cat</code>等。</p>
<p>Shell 在寻找命令时，会先在内建命令中查找，如果找不到，就会在外部命令中查找。所以，当你尝试执行一个不存在的命令时，shell会提示你<code>command not found</code>，就像下面这样：</p>
<pre><code class="language-bash">[caiyi@archlinux Desktop]$ firetruck you
bash: firetruck: command not found
</code></pre>
<p>需要说明的是，只有第一个单词是命令，比如上面的<code>firetruck</code>和<code>git</code>，shell 会去寻找一个叫<code>firetruck</code>或者<code>git</code>的程序。后面的一切都是参数，shell 会把这些参数传递给这个程序。</p>
<p>例如，在执行<code>git --version</code>时，<code>--version</code>就是参数。程序根据不同的参数执行不同的操作。</p>
<p>还记得main函数的完整形式？通过argv向量，程序就可以访问到这些参数。</p>
<pre><code class="language-c">// 省略了 envp 参数，避免让新手头大
int main(int argc, char *argv[]) {
    // argc 是参数的数量
    // argv 是参数的数组
}
</code></pre>
<p>让我们写一个简单的程序来获取所有的参数。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    for (int i = 0; i &lt; argc; i++)
    {
        printf(&quot;argv[%d]: %s\n&quot;, i, argv[i]);
    }

    return 0;
}
</code></pre>
<p>编译后，我们使用以下参数运行这个程序，可以得到以下输出：</p>
<pre><code class="language-bash">caiyi@archlinux ~&gt; ./argv_demo --version
argv[0]: ./argv_demo
argv[1]: --version
</code></pre>
<p>可以看到，<code>--version</code>这个参数被传递给了这个程序。但是值得注意的一点是，第一个参数并不是<code>--version</code>，而是程序的名字。这是因为，程序可能在运行时希望获得自己的完整路径，通过将<strong>当前工作目录</strong>和<strong>程序名</strong>拼接起来，程序就可以获得自己的完整路径。</p>
<h2 id="认识路径"><a class="header" href="#认识路径">认识路径</a></h2>
<p>以这个路径为例：<code>/home/caiyi/Desktop</code>。</p>
<p>路径表示文件系统中的位置，既可以是文件夹，也可以是文件。</p>
<p>路径分为绝对路径和相对路径。在Unix风格的路径中，判断一个路径是绝对路径还是相对路径很简单：如果路径以<code>/</code>开头，那么这个路径就是绝对路径，否则就是相对路径。</p>
<p>绝对路径是从<strong>根目录</strong>开始的路径，相对路径是相对于当前工作目录的路径。</p>
<p>看到一个路径，请你的大脑将这个路径按'/'分割成一个数组：<code>['home', 'caiyi', 'Desktop']</code>。</p>
<p>除最后一个元素外，每个元素都是一个文件夹。最后一个元素既可以是文件夹也可以是文件。但是如果最后一个元素后面还跟了一个<code>/</code>，那么这个元素就是一个文件夹。</p>
<p>上面的例子中，由于是一个绝对路径，所以它的含义是
根目录下的<code>home</code>文件夹下的<code>caiyi</code>文件夹下的<code>Desktop</code>文件夹（或文件夹）。</p>
<p>下面来看一个相对路径的例子：<code>repos/manual/</code></p>
<p>这个路径是相对路径，因为它不是以<code>/</code>开头的。这个路径的含义是<strong>当前工作目录</strong>下的<code>repos</code>文件夹下的<code>manual</code>文件夹<sup class="footnote-reference"><a href="#2">2</a></sup>。</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>前面说了，如果最后一个元素后面还跟了一个<code>/</code>，那么这个元素就是一个文件夹。</p>
</div>
<h3 id="特殊的路径"><a class="header" href="#特殊的路径">特殊的路径</a></h3>
<p>前面介绍了<code>/</code>和<code>~</code>这两个特殊的路径。它们分别表示根目录和用户的家目录。</p>
<p><code>/</code>是根目录，是文件系统的最顶层。在 Unix 系统中，所有的文件和文件夹都是从根目录开始的。</p>
<p><code>~</code>是用户的家目录，是用户的默认工作目录。在 Unix 系统中，用户的家目录一般是<code>/home/&lt;用户名&gt;</code>。</p>
<p>下面再介绍两个特殊的路径：<code>.</code>和<code>..</code>。</p>
<p><code>.</code>表示当前工作目录，是一个相对路径。例如，<code>./repos</code>表示当前工作目录下的<code>repos</code>文件夹。它就等价于<code>repos</code>。</p>
<p><code>..</code>表示上一级目录，是一个相对路径。例如，<code>../repos</code>表示当前工作目录的上一级目录下的<code>repos</code>文件夹。</p>
<h2 id="基本命令"><a class="header" href="#基本命令">基本命令</a></h2>
<p>从现在开始，你就要像一个程序员一样使用命令行了。在这一节中，我们会学习一些基本的命令。</p>
<p>一般来说，你使用的命令只有两类：</p>
<ol>
<li>更改工作目录的命令</li>
<li>执行程序或操作</li>
</ol>
<h3 id="更改工作目录的命令"><a class="header" href="#更改工作目录的命令">更改工作目录的命令</a></h3>
<p>更改工作目录的一般使用<code>cd</code>命令。<code>cd</code>是<code>change directory</code>的缩写。</p>
<p><code>cd</code> 后既可以接绝对路径，也可以接相对路径。</p>
<p>使用绝对路径：</p>
<pre><code class="language-bash">cd /home/caiyi/Desktop
</code></pre>
<p>现在你的工作目录就变成了<code>/home/caiyi/Desktop</code>。输入pwd命令，你会看到输出是<code>/home/caiyi/Desktop</code>。同时在提示符附近也可以看到当前工作目录。</p>
<p>再使用相对路径：</p>
<pre><code class="language-bash">cd repos/manual
</code></pre>
<p>现在你的工作目录就变成了<code>/home/caiyi/Desktop/repos/manual</code>。输入pwd命令，你会看到输出是<code>/home/caiyi/Desktop/repos/manual</code>。</p>
<p>通常来说，使用相对路径更方便，因为你不需要记住绝对路径。要进入当前工作目录下的一个文件夹，只需要输入<code>cd 文件夹名</code>即可。</p>
<p>现在来看看<code>..</code>和<code>.</code>的用法。</p>
<pre><code class="language-bash">cd ..
</code></pre>
<p>输入这个命令后，你的工作目录就变成了原来工作目录的上一级目录。输入<code>pwd</code>命令，你会看到输出是<code>/home/caiyi/Desktop/repos</code>。</p>
<pre><code class="language-bash">cd .
</code></pre>
<p>输入这个命令后，你的工作目录不会发生变化。因为<code>.</code>表示当前工作目录。虽然<code>.</code>在现在看起来好像没什么用，但是在某些情况下，<code>.</code>是非常有用的。后面我们会提到。</p>
<h3 id="执行程序或操作"><a class="header" href="#执行程序或操作">执行程序或操作</a></h3>
<p>在命令行中，你可以执行程序或者操作。这些程序或操作可以是内建的，也可以是外部的。</p>
<h4 id="内建命令"><a class="header" href="#内建命令">内建命令</a></h4>
<h5 id="pwd"><a class="header" href="#pwd"><code>pwd</code></a></h5>
<p><code>pwd</code>是<code>print working directory</code>的缩写。这个命令会输出当前工作目录的绝对路径。</p>
<p>样例输出：</p>
<pre><code class="language-bash">pwd
</code></pre>
<p>输出的内容是<code>/home/caiyi/</code>。</p>
<h5 id="ls"><a class="header" href="#ls"><code>ls</code></a></h5>
<p><code>ls</code>是<code>list</code>的缩写。这个命令会列出当前工作目录下的所有文件和文件夹。</p>
<p>样例输出：</p>
<pre><code class="language-bash">LICENSE  book/  book.toml  src/
</code></pre>
<p>这是当前本仓库的根目录的输出。你可以看到有四个文件和文件夹。文件夹都以<code>/</code>结尾，其他的都是文件。</p>
<p><code>ls</code>命令还有一些选项，常用的有<code>-l</code>和<code>-a</code>。</p>
<p><code>-l</code>选项会输出更详细的信息，包括文件的权限，所有者，大小，修改时间等。</p>
<p>例如：</p>
<pre><code class="language-bash">caiyi@archlinux ~/r/manual (use-git)&gt; ls -l
total 16
-rw-r--r-- 1 caiyi caiyi 1064 Aug  5 14:57 LICENSE
drwxr-xr-x 7 caiyi caiyi 4096 Aug  5 19:03 book/
-rw-r--r-- 1 caiyi caiyi  148 Aug  5 15:29 book.toml
drwxr-xr-x 4 caiyi caiyi 4096 Aug  5 18:40 src/
</code></pre>
<p><code>-a</code>选项会输出所有的文件和文件夹，包括隐藏的文件和文件夹。隐藏的文件和文件夹以<code>.</code>开头。</p>
<pre><code class="language-bash">caiyi@archlinux ~/r/manual (use-git)&gt; ls -a
./  ../  .git/  .github/  .gitignore  LICENSE  book/  book.toml  src/
</code></pre>
<p>更多的用法请上网查询。</p>
<h5 id="rm"><a class="header" href="#rm"><code>rm</code></a></h5>
<p><code>rm</code>是<code>remove</code>的缩写。这个命令会删除文件或者文件夹。</p>
<h6 id="删除文件"><a class="header" href="#删除文件">删除文件</a></h6>
<p>直接输入<code>rm</code>，然后将文件路径作为参数传递给<code>rm</code>。</p>
<p>例如</p>
<pre><code class="language-bash">rm LICENSE
rm ./LICENSE
rm ../LICENSE
</code></pre>
<h6 id="删除文件夹"><a class="header" href="#删除文件夹">删除文件夹</a></h6>
<p>如果一个文件夹不为空，你不能直接删除它。
但是有一个简单的方法可以删除一个文件夹及其所有内容，就是使用<code>-r</code>选项。<code>r</code>是<code>recursive</code>的缩写，表示递归。</p>
<pre><code class="language-bash">rm -r book/
</code></pre>
<p>这个命令会删除<code>book</code>文件夹及其所有内容。</p>
<p>网上有很多人开玩笑的让新手输入<code>sudo rm -rf /</code>这个命令，这是<strong>相当危险的</strong>。它会递归删除根目录下的所有文件和文件夹。包括boot分区和所有数据资料。所以，<strong>请不要输入这个命令</strong>。</p>
<p>同时，在删除当前文件夹下所有文件时，有些人喜欢用<code>rm -rf ./</code>，建议不要使用这种方法，而是输入完整的文件夹名字，因为它和上面的命令相似，如果你输入错误，就会发生灾难性的后果。</p>
<h6 id="删除多个文件"><a class="header" href="#删除多个文件">删除多个文件</a></h6>
<p>你可以一次删除多个文件。</p>
<pre><code class="language-bash">rm LICENSE book.toml
</code></pre>
<p>这个命令会删除<code>LICENSE</code>和<code>book.toml</code>这两个文件。</p>
<h5 id="mv"><a class="header" href="#mv">mv</a></h5>
<p><code>mv</code>是<code>move</code>的缩写。这个命令可以移动文件或者文件夹。</p>
<pre><code class="language-bash">mv LICENSE book/
</code></pre>
<p>这个命令会将<code>LICENSE</code>文件移动到<code>book</code>文件夹下。</p>
<pre><code class="language-bash">mv book/ book-old/
</code></pre>
<p>这个命令会将<code>book</code>文件夹<strong>重命名</strong>为<code>book-old</code>。Unix下没有专门的重命名命令，重命名就是移动。</p>
<h5 id="cp"><a class="header" href="#cp">cp</a></h5>
<p><code>cp</code>是<code>copy</code>的缩写。这个命令可以复制文件或者文件夹。其语法和<code>mv</code>类似。这里不再赘述。</p>
<pre><code class="language-bash">cp LICENSE book/
</code></pre>
<p>把<code>LICENSE</code>文件复制到<code>book</code>文件夹下。</p>
<h5 id="mkdir"><a class="header" href="#mkdir">mkdir</a></h5>
<p><code>mkdir</code>是<code>make directory</code>的缩写。这个命令可以创建文件夹。</p>
<pre><code class="language-bash">mkdir new-folder
</code></pre>
<p>这个命令会在当前工作目录下创建一个叫<code>new-folder</code>的文件夹。</p>
<h6 id="创建多级文件夹"><a class="header" href="#创建多级文件夹">创建多级文件夹</a></h6>
<pre><code class="language-bash">mkdir -p new-folder/sub-folder
</code></pre>
<p>这个命令会创建一个叫<code>new-folder</code>的文件夹，然后在这个文件夹下创建一个叫<code>sub-folder</code>的文件夹。</p>
<h5 id="touch"><a class="header" href="#touch">touch</a></h5>
<p><code>touch</code>命令会创建一个空文件。</p>
<pre><code class="language-bash">touch new-file
</code></pre>
<p>这个命令会在当前工作目录下创建一个叫<code>new-file</code>的文件。</p>
<h4 id="外部命令"><a class="header" href="#外部命令">外部命令</a></h4>
<p>常用的内部命令就以上这几个，它们覆盖了你在日常工作中的大部分需求。但是有时候你需要使用一些外部命令。</p>
<h5 id="cat"><a class="header" href="#cat">cat</a></h5>
<p><code>cat</code>是<code>concatenate</code>的缩写。这个命令会输出文件的内容。很多人认为<code>cat</code>是一个内建命令，但是它实际上是一个外部命令。</p>
<pre><code class="language-bash">cat LICENSE
</code></pre>
<p>这个命令会输出<code>LICENSE</code>文件的内容。
例如：</p>
<pre><code class="language-ascii">caiyi@archlinux ~/r/manual (use-git)&gt; cat LICENSE 
MIT License

Copyright (c) 2024 NEUQ-CS

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<h5 id="echo"><a class="header" href="#echo">echo</a></h5>
<p><code>echo</code>命令会输出参数。</p>
<pre><code class="language-bash">echo &quot;Hello, World!&quot;
</code></pre>
<p>这个命令会输出<code>Hello, World!</code>。</p>
<h5 id="其他命令"><a class="header" href="#其他命令">其他命令</a></h5>
<p>对于其他命令，只要它在环境变量<code>PATH</code>中，你就可以直接使用。使用<code>echo $PATH</code>，你可以看到<code>PATH</code>中包含了哪些路径。这些路径就是系统用来查找命令的路径。在这些路径下的<strong>可执行文件</strong>都可以直接使用。</p>
<p>我们使用的<code>git</code>命令就是一个外部命令。如果是 Unix 系统，git 在<code>/usr/bin</code>或者<code>/usr/local/bin</code>中会有一个链接指向真正的可执行文件。在 Windows 系统中，git 会被安装到<code>C:\Program Files\Git\bin</code>中或者你自己指定的路径。</p>
<p>如果你不知道一个命令是不是内建命令，你可以使用<code>which</code>命令来查找。</p>
<h5 id="运行任意程序"><a class="header" href="#运行任意程序">运行任意程序</a></h5>
<p>前面我们讲了运行在环境变量<code>PATH</code>中的程序。但是有时候你需要运行一个不在<code>PATH</code>中的程序。比如你用<code>gcc</code>在当前目录下编译了一个程序，你显然不会先把当前目录加入<code>PATH</code>再运行这个程序。</p>
<p>这时候你可以使用相对路径或者绝对路径来运行这个程序。</p>
<p>对于<strong>非当前目录</strong>下的程序，你可以使用相对路径或者绝对来运行，例如：</p>
<pre><code class="language-bash"># 使用绝对路径
caiyi@archlinux ~&gt; ~/argv_demo --version
# 使用相对路径
caiyi@archlinux ~&gt; ../tmp/argv_demo --version
</code></pre>
<p>对于当前目录下的程序，这时候就需要使用<code>.</code>了。你需要使用<code>./&lt;程序名&gt;</code>来运行这个程序，例如：</p>
<pre><code class="language-bash">caiyi@archlinux ~&gt; ./argv_demo --version
</code></pre>
<p>这是为了避免歧义，如果不输入<code>./</code>，这种格式完全符合<em>命令</em>的格式，因此shell会把它当作命令来执行。</p>
<h6 id="权限问题"><a class="header" href="#权限问题">权限问题</a></h6>
<p>在 Unix 系统中，程序需要有执行权限（Executable）才能运行。有时你从网上下载了一个二进制文件，你发现你不能运行它，这是因为它没有执行权限。</p>
<p>这时候就需要使用<code>chmod</code>命令来添加执行权限。</p>
<pre><code class="language-bash">chmod +x argv_demo
</code></pre>
<p>这样你就可以运行这个程序了。</p>
<p>UNIX的权限分为可读可写可执行三种权限，分别用<code>r</code>，<code>w</code>，<code>x</code>表示。对于文件夹，<code>x</code>表示可以进入这个文件夹。也可以使用三个比特二进制表示：</p>
<pre><code>000
</code></pre>
<p>其中第一个比特表示可执行权限，第二个比特表示可写权限，第三个比特表示可读权限。</p>
<p>当权限为0时表示为既不可读也不可写也不可执行。当权限为7时表示可读可写可执行。</p>
<h3 id="链接"><a class="header" href="#链接">链接</a></h3>
<p>在 Unix 系统中，有两种链接：符号链接（也叫软链接）和硬链接。</p>
<p>它们都是一种特殊的文件，它们<strong>指向</strong>另一个文件。软链接在 Windows 下叫做快捷方式。软链接在 Unix 下有两种，一种是符号链接，另一种是硬链接。符号链接是一种特殊的文件，它指向另一个文件。硬链接是一个文件的另一个名字。</p>
<p>指向意味着，当你访问这个链接时，实际上你访问的是被链接的文件。这样，你可以在不改变文件的情况下，改变文件的位置。同时，你也可以在不占用额外空间的情况下，创建一个文件的副本。</p>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>环境变量是一种特殊的变量，它们是在操作系统启动时设置的。环境变量是一个键值对。键是环境变量的名字，值是环境变量的值。</p>
<p>对于新手来说，你只需要了解两个环境变量：<code>PATH</code>和<code>HOME</code>。</p>
<p><code>PATH</code>是一个包含了系统用来查找命令的路径的变量。当你输入一个命令时，系统会在<code>PATH</code>中的路径下查找这个命令。如果找到了，就会执行这个命令。如果没有找到，就会提示<code>command not found</code>。</p>
<p><code>HOME</code>是用户的家目录。在 Unix 系统中，用户的家目录一般是<code>/home/&lt;用户名&gt;</code>。前面说的<code>~</code>是家的别名是不准确的，事实上，它是<code>HOME</code>环境变量的值。如果你修改了<code>HOME</code>环境变量，<code>~</code>也会随之改变。</p>
<p>你可以使用<code>echo</code>命令来查看环境变量的值。</p>
<pre><code class="language-bash">echo $PATH
</code></pre>
<p>'$'符号是一个特殊字符，它表示后面的是一个变量。在这个例子中，<code>$PATH</code>表示<code>PATH</code>环境变量的值。</p>
<p>在 C 语言中的完整main函数的形式是这样的：</p>
<pre><code class="language-c">int main(int argc, char *argv[], char *envp[]) {
    // argc 是参数的数量
    // argv 是参数的数组
    // envp 是环境变量的数组
}
</code></pre>
<p>是的，这才是完整的main函数，它接受3个参数而不是大多数教程中的2个参数。</p>
<p>遍历<code>envp</code>向量即可得到所有的环境变量。环境变量向量可能非常长，因此在这里不再展示。</p>
<p>环境变量以及参数都是父进程在变为子进程时通过<code>exec</code>系统调用让<strong>操作系统</strong>传递给子进程的。并且<code>argc</code>,<code>argv</code>,<code>envp</code>是子进程主线程线程栈最顶端的元素。</p>
<h3 id="命令的选项"><a class="header" href="#命令的选项">命令的选项</a></h3>
<p>命令的选项也是一种参数，但是它们以<code>-</code>或者<code>--</code>开头。选项可以改变命令的行为。</p>
<p><code>-</code>选项是单字母的选项，<code>--</code>选项是多字母的选项。</p>
<p>对于某些程序，例如<code>ls</code>，<code>-</code>选项可以合并，比如<code>-a -l</code>可以写成<code>-al</code>。</p>
<p>一般来说，对大部分程序使用<code>-h</code>或者<code>--help</code>选项可以查看帮助信息。</p>
<p>选项分为两种：有参数的选项和无参数的选项。有参数的选项后面需要跟一个参数，无参数的选项不需要。</p>
<p>上面提到的<code>--help</code>就是是无参数的选项。</p>
<p>例如，某款游戏可能接受<code>--fullscreen true</code>这样的选项，<code>--fullscreen</code>是有参数的选项，<code>true</code>是这个选项的参数。但是它们都是命令中的参数。</p>
<h3 id="管道"><a class="header" href="#管道">管道</a></h3>
<p>管道是Unix中较为复杂的概念，在这里我只讲如何使用。</p>
<p>管道的作用是<strong>重定向命令的输出</strong>。你可以把一个命令的输出作为另一个命令的输入。也可以把一个命令的输出保存到文件中。</p>
<h4 id="重定向到另一个程序的标准输入"><a class="header" href="#重定向到另一个程序的标准输入">重定向到另一个程序的标准输入</a></h4>
<pre><code class="language-bash">echo &quot;Hello, World!&quot; | cat
</code></pre>
<p>首先，<code>echo &quot;Hello, World!&quot;</code>会输出<code>Hello, World!</code>。然后，<code>|</code>会把这个输出重定向到<code>cat</code>命令的标准输入。<code>cat</code>会输出这个输入。所以输出还是<code>Hello, World!</code>。</p>
<h4 id="重定向到文件"><a class="header" href="#重定向到文件">重定向到文件</a></h4>
<pre><code class="language-bash">echo &quot;Hello, World!&quot; &gt; hello.txt
</code></pre>
<p>这个命令会把<code>echo &quot;Hello, World!&quot;</code>的输出重定向到<code>hello.txt</code>文件中。<code>&gt;</code>是重定向的符号。</p>
<p>现在你可以使用<code>cat</code>命令查看这个文件的内容。</p>
<pre><code class="language-bash">cat hello.txt
</code></pre>
<h4 id="重定向到文件的末尾"><a class="header" href="#重定向到文件的末尾">重定向到文件的末尾</a></h4>
<pre><code class="language-bash">echo &quot;Hello, World!&quot; &gt;&gt; hello.txt
</code></pre>
<p>这个命令会把<code>echo &quot;Hello, World!&quot;</code>的输出<strong>追加</strong>到<code>hello.txt</code>文件的末尾。<code>&gt;&gt;</code>是追加重定向的符号。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-入门"><a class="header" href="#git-入门">Git 入门</a></h1>
<p>在了解了命令行的基本操作后，我们来尝试使用 Git。这部分的内容是命令和原理结合的，你可以在这里学到 Git 的基本操作和 Git 的工作原理。</p>
<p>获得一个 Git 仓库的方法有两种，一种是“将一个文件夹变成 Git 仓库”，一种是从远程<strong>克隆</strong>一个 Git 仓库。</p>
<h2 id="将一个文件夹变成一个-git-仓库"><a class="header" href="#将一个文件夹变成一个-git-仓库">将一个文件夹变成一个 Git 仓库</a></h2>
<p>Git 仓库的本质是一个文件夹。所以，我们可以将一个文件夹变成一个 Git 仓库。</p>
<p>你可以输入以下命令，把当前文件夹变成一个 Git 仓库：</p>
<pre><code class="language-bash">git init
</code></pre>
<p>或者，你可以输入以下命令，把指定文件夹变成一个 Git 仓库：</p>
<pre><code class="language-bash">git init path/to/folder
</code></pre>
<p>Git 仓库和普通文件夹的区别在于，Git 仓库中有一个隐藏的<code>.git</code>文件夹，这个文件夹中存储了 Git 的所有信息，包括所有的git object，ref等。在任何情况下，你都不要应该修改<code>.git</code>文件夹中任何的内容。唯一的例外是<code>.git/config</code>文件，这个文件存储了当前仓库的配置信息，例如远程仓库的地址等。但是你也应该谨慎修改这个文件或者使用<code>git config</code>命令修改配置。</p>
<p>如果你不小心把一个文件夹变成了 Git 仓库<sup class="footnote-reference"><a href="#1">1</a></sup>，直接删除<code>.git</code>文件夹就可以了。使用以下命令即可：</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>去年有人才把整个C盘或者桌面都变成了Git仓库。</p>
</div>
<pre><code class="language-bash">rm -rf .git
</code></pre>
<p>Git 在操作 Git 仓库时，会递归的从当前文件夹向上查找<code>.git</code>文件夹，直到找到<strong>第一个</strong><code>.git</code>文件夹或者到达文件系统的根目录。所以，你可以在任何一个 Git 仓库的子文件夹中使用 Git 命令。当 Git 仓库嵌套时，Git 会使用离当前文件夹最近的<code>.git</code>文件夹。</p>
<h2 id="克隆远程仓库"><a class="header" href="#克隆远程仓库">克隆远程仓库</a></h2>
<p>要从远程克隆仓库首先要确保你具有权限，对于 GitHub，GitLab, Bitbucket等代码托管平台的公开仓库，任何人都具有权限，因此可以直接克隆。对于私有仓库，你需要一个具有读取权限的平台账号，然后将平台账户和你的 SSH 密钥绑定。</p>
<p>具有权限后，就能够克隆仓库了，使用以下命令即可：</p>
<pre><code class="language-bash">git clone https://github.dev/NEUQ-CS/manual.git
</code></pre>
<p>记得将仓库地址更换成你想克隆的仓库的地址。克隆结束后，在<strong>当前目录</strong>下会产生一个与仓库名一致的文件夹，在本例中，是<code>manual</code>。
这个仓库就是你克隆的 Git 仓库。</p>
<p><code>clone</code>命令还有一些其他参数可以使用</p>
<h4 id="克隆到指定文件夹"><a class="header" href="#克隆到指定文件夹">克隆到指定文件夹</a></h4>
<p>在地址后面加上指定路径即可：</p>
<pre><code class="language-bash">git clone https://github.dev/NEUQ-CS/manual.git path/to/repo
</code></pre>
<p>注意，仓库里的文件会直接存在你指定的文件夹里面，而不是在你指定的目录里放仓库文件夹。</p>
<h4 id="克隆指定分支"><a class="header" href="#克隆指定分支">克隆指定分支</a></h4>
<p>加上参数<code>-b &lt;分支名&gt;</code>即可，例如:</p>
<pre><code class="language-bash">git clone https://github.dev/NEUQ-CS/manual.git -b master
</code></pre>
<p>这将指定需要克隆master分支.</p>
<p>需要说明的是，即使你选择了一个分支，整个仓库的所有分支都实质上会被克隆下来，只是克隆完成后位于指定分支。</p>
<h4 id="指定克隆深度"><a class="header" href="#指定克隆深度">指定克隆深度</a></h4>
<p>使用<code>--depth &lt;深度&gt;</code>来指定克隆深度：</p>
<pre><code class="language-bash">git clone https://github.dev/NEUQ-CS/manual.git --depth=1
</code></pre>
<p>仅克隆主分支上包含最新一个提交的完整仓库，克隆的仓库<strong>不含有</strong>任何历史记录。不推荐使用，除非你只是为了临时下载代码并且不需要历史记录和其他分支。</p>
<h2 id="查看-git-仓库的状态"><a class="header" href="#查看-git-仓库的状态">查看 Git 仓库的状态</a></h2>
<p>在一个 Git 仓库中，你可以使用以下命令查看当前仓库的状态：</p>
<pre><code class="language-bash">git status
</code></pre>
<p>你会看到以下输出：</p>
<pre><code>On branch master
Your branch is up to date with 'origin/use-git'.

Changes to be committed:
  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
        modified:   src/use-git/configure.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        src/use-git/try-git.md

</code></pre>
<p>当前在分支<code>master</code>上，你的分支是最新的。<code>Changes to be committed</code>中列出了你修改的文件，<code>Untracked files</code>中列出了你新建的文件。</p>
<h3 id="git-工作原理"><a class="header" href="#git-工作原理">Git 工作原理</a></h3>
<p>在继续尝试前，我们先来了解一下 Git 的工作原理，你可能已经对上面的输出感到迷惑了。</p>
<p>在一个 Git 仓库的文件夹中，一个文件可能存在以下三种状态的其中一种：</p>
<ul>
<li>未跟踪　Untracked</li>
<li>已跟踪  Tracked</li>
<li>暂存中  Staged</li>
</ul>
<h4 id="未跟踪"><a class="header" href="#未跟踪">未跟踪</a></h4>
<p>当你使用 <code>git init</code>初始化一个仓库时，原有的所有文件都是<strong>未跟踪</strong>。Git <strong>不会</strong>管理任何未跟踪的文件，但是这个文件仍然存在于这个文件夹中。<em>不会管理</em>的意思在于，当你通过 git 操作仓库的状态时，未跟踪的文件不会被修改或删除。如果一定会造成修改<sup class="footnote-reference"><a href="#2">2</a></sup>，git 会阻止这次操作，直到你解决完冲突。</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>比如你有一个未跟踪的a.txt，然后你通过切换到另一个分支，合并另一个分支，拉取远程尝试覆盖（其他分支上存在已跟踪的a.txt）这个文件时，Git 会阻止这次操作。</p>
</div>
<h4 id="已跟踪"><a class="header" href="#已跟踪">已跟踪</a></h4>
<p>这应该是仓库中大部分文件存在的状态。当你刚远程克隆完一个仓库时，所有文件都处于已跟踪状态。这是显然的，因为只有被跟踪的文件才会被提交到远程服务器。</p>
<h5 id="跟踪未跟踪的文件"><a class="header" href="#跟踪未跟踪的文件">跟踪未跟踪的文件</a></h5>
<p>要把一个未跟踪的文件变为已跟踪状态的方法是，先添加到<strong>暂存区</strong>，然后再commit。以下是命令行教程</p>
<pre><code class="language-bash"># 添加a_new_file到暂存区
git add a_new_file
# commit在暂存区的所有文件
git commit -m &quot;add `a_new_file` to this repo&quot;
</code></pre>
<h5 id="将已跟踪的文件删除"><a class="header" href="#将已跟踪的文件删除">将已跟踪的文件删除</a></h5>
<p>你可以使用<code>git rm &lt;文件&gt;</code>来删除，这会直接把删除操作直接添加到暂存区，文件系统上的文件也会被删除。它等价于以下操作：</p>
<pre><code class="language-bash">rm an_old_file
git add an_old_file
</code></pre>
<p>要取消跟踪一个文件，但希望在文件系统上保留这个文件，使用<code>git rm --cached file</code></p>
<h4 id="暂存中"><a class="header" href="#暂存中">暂存中</a></h4>
<p>准确地说，暂存的不是文件，是操作。通常来说，可以暂存</p>
<ul>
<li>修改 Modify/Update</li>
<li>添加 Add</li>
<li>删除 delete</li>
<li>移动 Move</li>
</ul>
<p>这几种操作。</p>
<p>当你在文件系统上修改一个文件，然后用<code>git add</code>的时候会暂存一个<code>修改</code>操作到暂存区。
当你在文件系统上添加一个文件，然后用<code>git add</code>的时候会暂存一个<code>添加</code>操作到暂存区。
当你在文件系统上删除一个文件，然后用<code>git add</code>的时候会暂存一个<code>删除</code>操作到暂存区。
当你在文件系统上移动或重命名一个文件，然后用<code>git add</code>的时候会暂存一个<code>移动</code>操作到暂存区。</p>
<p>将操作从暂存区撤出，使用以下命令：</p>
<pre><code class="language-bash">git restore --staged file
</code></pre>
<p>对于这些状态的理解，我推荐使用Visual studio code的内置Git功能进行观察，他是Git的一个前端。可以代替手动的命令行，但是，就我个人而言，更会倾向使用命令行，因为这些前端<strong>不支持</strong>较为复杂的操作。</p>
<p>现在我们再来看这段输出：</p>
<pre><code class="language-ascii">On branch master
Your branch is up to date with 'origin/use-git'.

Changes to be committed:
  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
        modified:   src/use-git/configure.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        src/use-git/try-git.md

</code></pre>
<p>Changes to be committed部分就是存在于暂存区的文件，当我们使用<code>git commit</code>的时候，就会跟踪并把这些文件添加到git仓库。</p>
<p>Untracked files是前文说过的未跟踪文件，这是因为这个文件才创建，当使用<code>git add</code>来添加时，会在暂存区添加一个<code>添加</code>操作。</p>
<h4 id="代码提交"><a class="header" href="#代码提交">代码提交</a></h4>
<p>代码提交使用<code>git commit</code>命令，提交的时候需要一段简短的话描述你的这次修改。同时，你的姓名，邮箱也会被记录在这条commit记录中。</p>
<p>关于如何编写commit信息，我会在后面讲解良好的git使用习惯时讲到。</p>
<p><code>git commit</code>命令常用的形式有以下两种：</p>
<ol>
<li>将信息作为参数直接提交</li>
</ol>
<pre><code class="language-bash">git commit -m &quot;&lt;提交信息&gt;&quot;
</code></pre>
<ol start="2">
<li>使用代码编辑器编写提交信息</li>
</ol>
<pre><code class="language-bash">git commit -a
</code></pre>
<p>这会打开你在安装时选择的代码编辑器，信息编写完成后，保存关闭即可。</p>
<p>有时候，你觉得提交信息写的不好，打算重写编写提交信息时，可以采用以下命令：</p>
<pre><code class="language-bash">git commit --amend -m &quot;&lt;提交信息&gt;&quot;
</code></pre>
<p>或者使用编辑器</p>
<pre><code class="language-bash">git commit --amend -a
</code></pre>
<p>这会完全重新提交一次commit并获得不同的commit哈希<sup class="footnote-reference"><a href="#3">3</a></sup>，以及时间戳。</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>还记得 Git 是去中心化这句话吗？使用哈希来描述对象是去中心化的典型特征。哈希是指向去中心化网络中对象的一个指针，具有这个指针就能够访问到这个对象，当没有人持有哈希时，这个对象就<em>视为</em>被删除，但是这个对象本身实际上不能被删除，它仍存在于去中心化网络中。Git 的commit也是，这也就意味着，当你在GitHub上删除一个仓库，分支时，它实际上从未被删除，也不能够被删除。</p>
</div>
<p>使用<code>git commit --amend</code>的操作等价于以下操作：</p>
<pre><code class="language-bash"># 保留修改回到上一次提交
git reset --soft &quot;HEAD^&quot;
# 重新提交
git commit -m &quot;&lt;提交信息&gt;&quot;
</code></pre>
<p>我个人更喜欢这种方法，因为更为灵活，你可以在重新提交过程中做一些修改。</p>
<h4 id="查看提交历史"><a class="header" href="#查看提交历史">查看提交历史</a></h4>
<p>使用<code>git log</code>命令可以查看提交历史，这会列出所有的提交记录，包括提交哈希，提交信息，提交时间，提交者等信息。</p>
<h4 id="推送到远程仓库"><a class="header" href="#推送到远程仓库">推送到远程仓库</a></h4>
<p>尽管我还没有教你配置远程仓库，但是我还是会告诉你如何推送到远程仓库。</p>
<p>使用<code>git push</code>命令可以将本地仓库的修改推送到远程仓库。这个命令的形式是：</p>
<pre><code class="language-bash">git push &lt;远程仓库名&gt; &lt;本地分支&gt;:&lt;远程分支&gt;
</code></pre>
<p>通常来说，远程仓库名是<code>origin</code>。并且，大多数时候，本地分支和远程分支是一样的，所以可以省略远程分支：</p>
<pre><code class="language-bash">git push origin &lt;分支&gt;
</code></pre>
<p>这会将本地分支推送到远程分支，如果远程分支不存在，会自动创建。</p>
<p>有时候，远程分支上包含了你不希望存在的修改，这时候你想用本地分支覆盖远程分支，可以使用<code>-f</code>参数：</p>
<pre><code class="language-bash">git push -f origin &lt;分支&gt;
</code></pre>
<p><code>-f</code>选项会强制推送，这会覆盖远程分支上的所有修改，所以请谨慎使用。如果你把别人的代码或者作业给覆盖了，小心被打。</p>
<p>在推送之前，你需要先确保你具有远程仓库的所有历史记录，如果本地仓库不包含远程仓库存在的一些更改，你就需要先拉取远程仓库的更改。</p>
<h4 id="拉取远程仓库的修改"><a class="header" href="#拉取远程仓库的修改">拉取远程仓库的修改</a></h4>
<p>拉取远程仓库的修改使用<code>git pull</code>命令，这会将远程仓库的修改拉取到本地仓库。这个命令的形式是：</p>
<pre><code class="language-bash">git pull &lt;远程仓库名&gt; &lt;远程分支&gt;:&lt;本地分支&gt;
</code></pre>
<p>同样，大多数时候，远程仓库名是<code>origin</code>，远程分支和本地分支是一样的，所以可以省略远程分支：</p>
<pre><code class="language-bash">git pull origin &lt;分支&gt;
</code></pre>
<p>这会将远程分支拉取到本地分支，如果本地分支不存在，会自动创建。</p>
<p><code>git pull</code>命令实际上是<code>git fetch</code>和<code>git merge</code>的组合，<code>git fetch</code>会将远程仓库的修改拉取到本地仓库，但不会应用更改，而是会在一个<code>&lt;远程名&gt;/&lt;分支名&gt;</code>的分支上保存，<code>git merge</code>会将这个特殊分支合并到本地分支。</p>
<h3 id="分支"><a class="header" href="#分支">分支</a></h3>
<p>前面提到了那么多关于分支的内容，但是我还没有告诉你什么是分支。</p>
<p>分支是 Git 的一个重要概念，它是一个指向一个提交的指针。在一个 Git 仓库中，你可以有多个分支，每个分支指向一个提交。默认情况下，你会有一个<code>master</code><sup class="footnote-reference"><a href="#1">1</a></sup>分支。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>前几年由于一些政治正确的原因，在GitHub上，主分支被改成了<code>main</code></p>
</div>
<p>分支的意义在于它和其他分支可以并行开发，你可以在一个分支上开发一个新的功能，而不影响其他分支。当你开发完成后，你可以将这个分支<strong>合并</strong>到主分支上。合并会将当前分支上所有领先于基础分支的patch应用到基础分支上。这就是使用 Git 进行协作开发的原理。</p>
<p>了解了什么是分支，现在我来教你如何管理分支。</p>
<h4 id="查看分支"><a class="header" href="#查看分支">查看分支</a></h4>
<p>使用<code>git branch</code>命令可以查看当前<strong>本地仓库</strong>的所有分支。加上<code>-a</code>参数可以查看所有分支，包括远程分支。</p>
<p>样例输出：</p>
<pre><code class="language-bash">caiyi@archlinux ~/r/manual (use-git)&gt; git branch
  fix-ci
  fix-format
  main
  master
* use-git
caiyi@archlinux ~/r/manual (use-git)&gt; git branch -a
  fix-ci
  fix-format
  main
  master
* use-git
  remotes/origin/HEAD -&gt; origin/main
  remotes/origin/fix-ci
  remotes/origin/fix-format
  remotes/origin/main
  remotes/origin/master
  remotes/origin/use-git
</code></pre>
<p>上面的输出表明，我们当前在<code>use-git</code>分支上，本地仓库中有<code>fix-ci</code>, <code>fix-format</code>, <code>main</code>, <code>master</code>, <code>use-git</code>五个分支，远程仓库中有<code>fix-ci</code>, <code>fix-format</code>, <code>main</code>, <code>master</code>, <code>use-git</code>五个分支。</p>
<h4 id="创建分支"><a class="header" href="#创建分支">创建分支</a></h4>
<p>创建分支是<em>创建当前分支的拷贝</em>，因此要先切换到你想要拷贝的分支上，然后使用命令。</p>
<p>创建分支有两种命令：</p>
<ol>
<li></li>
</ol>
<pre><code class="language-bash">git checkout -b &lt;分支名&gt;
</code></pre>
<ol start="2">
<li></li>
</ol>
<pre><code class="language-bash">git branch -m &lt;分支名&gt;
</code></pre>
<p>这会创建一个新的分支，并切换到这个分支上。</p>
<p>要创建一个分支但不切换到这个分支上，可以使用以下命令：</p>
<pre><code class="language-bash">git branch &lt;分支名&gt;
</code></pre>
<h4 id="切换分支"><a class="header" href="#切换分支">切换分支</a></h4>
<p>当两个分支里的文件不一样时，切换分支会修改当前文件系统上的文件，因为切换分支意味着你要切换到另一个分支的文件系统状态。</p>
<p>切换分支使用<code>git checkout</code>命令，这会将当前分支切换到指定分支上：</p>
<pre><code class="language-bash">git checkout &lt;分支名&gt;
</code></pre>
<h4 id="删除分支"><a class="header" href="#删除分支">删除分支</a></h4>
<p>删除分支使用<code>git branch -d</code>命令，这会删除指定分支：</p>
<pre><code class="language-bash">git branch -d &lt;分支名&gt;
</code></pre>
<p>如果分支上有未合并的修改，Git 会拒绝删除这个分支。如果你确定要删除这个分支，可以使用<code>-D</code>参数：</p>
<pre><code class="language-bash">git branch -D &lt;分支名&gt;
</code></pre>
<h4 id="合并分支"><a class="header" href="#合并分支">合并分支</a></h4>
<p>合并分支有三种方法：</p>
<ul>
<li>合并 merge</li>
<li>变基 rebase</li>
<li>快进 fast-forward</li>
</ul>
<p>通常来说，使用<code>merge</code>即可，但是在一些特殊情况下，你可能需要使用<code>rebase</code>。快进是一种特殊的合并，当你的分支是基于基础分支的最新提交时，Git 会直接将基础分支指针指向当前分支指针，这就是快进。</p>
<p>合并分支使用<code>git merge</code>命令，这会将<strong>指定分支合并到当前分支上</strong>：</p>
<pre><code class="language-bash">git merge &lt;另一个分支&gt;
</code></pre>
<p>合并分支会产生一个新的提交commit，这个提交包含了两个分支的所有修改。</p>
<h4 id="变基"><a class="header" href="#变基">变基</a></h4>
<p>变基是一个相对复杂的概念，相对于<code>merge</code>来说，它能够让提交记录更加<em>线性</em>。这是因为，在合并后，分支继承了基础分支，也同时继承了合并分支，同时具有两个父节点。这会使得提交记录变得复杂，也就是更加<strong>不线性</strong>。</p>
<p>变基与合并不同的地方在于，它不会让分支同时继承两个父节点，而是将合并分支的提交记录放在基础分支的最新提交之后。提供更改的分支不会被继承，因而不会出现两个父节点。</p>
<p>变基使用<code>git rebase</code>命令，这会将<strong>指定分支变基到当前分支上</strong>：</p>
<pre><code class="language-bash">git rebase &lt;另一个分支&gt;
</code></pre>
<p>变基会产生一个新的提交commit，这个提交包含了两个分支的所有修改。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>本节课我们学习了 Git 的基本操作，包括将一个文件夹变成 Git 仓库，克隆远程仓库，查看 Git 仓库的状态，提交代码，查看提交历史，推送到远程仓库，拉取远程仓库的修改，分支的创建，切换，删除，合并，变基等操作。</p>
<p>这些操作需要你多加练习，只有多加练习，你才能熟练掌握这些操作。</p>
<p>要练习这些操作，我推荐使用这个网站：<a href="https://learngitbranching.js.org/">Learn Git Branching</a>。使用这个网站时，你只需要先掌握基本操作，以及操作远程仓库的操作，就可以了。对于更加复杂的操作，等你对 Git 有了更深的理解再去尝试。</p>
<p>但更重要的是，你应该多使用 Git 来管理你的代码，这样你才能更好地理解 Git 的工作原理。</p>
<p>下一节课开始，我们将学习如何使用代码托管平台，本教程以 GitHub 为例。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
